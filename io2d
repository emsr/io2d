#include <system_error>
#include <vector>
#include <map>
#include <functional>
#include <memory>
#include <limits>
#include <cmath> // min, max, clamp.
#include <optional> // nullopt_t?

namespace std
{
namespace experimental
{
namespace io2d
{
inline namespace v1
{

  enum class io2d_error
  {
    success,
    invalid_restore,
    no_current_point,
    invalid_matrix,
    invalid_status,
    null_pointer,
    invalid_string,
    invalid_path_data,
    read_error,
    write_error,
    surface_finished,
    invalid_dash,
    invalid_index,
    clip_not_representable,
    invalid_stride,
    user_font_immutable,
    user_font_error,
    invalid_clusters,
    device_error,
    invalid_mesh_construction,
  };

} // inline namespace v1
} // namespace io2d
} // namespace experimental

  template<>
    struct
    is_error_condition_enum<experimental::io2d::io2d_error>
    : public std::true_type
    { };

} // namespace std

namespace std
{
namespace experimental
{
namespace io2d
{
inline namespace v1
{

  class io2d_error_category
  : public std::error_category
  {
  public:

    // observers:

    virtual const char*
    name() const noexcept override;

    virtual string
    message(int errVal) const override;

    virtual bool
    equivalent(int code,
	       const std::error_condition& condition) const noexcept override;

    virtual bool
    equivalent(const std::error_code& __ec, int condition) const noexcept override;
  };

  // non-member functions:

  const error_category&
  io2d_category() noexcept;

} // inline namespace v1
} // namespace io2d
} // namespace experimental

  error_condition
  make_error_condition(experimental::io2d::io2d_error e) noexcept;

  std::error_code
  make_error_code(experimental::io2d::io2d_error e) noexcept;

} // namespace std

namespace std
{
namespace experimental
{
namespace io2d
{
inline namespace v1
{

  class rgba_color
  {
    // construct/copy/move/destroy:

    rgba_color() noexcept;

    rgba_color(double __r, double __g, double __b, double __a = 1.0)
    : _M_red{__r}, _M_green{__g}, _M_blue{__b}, _M_alpha{__a}
    { }

    rgba_color(double __r, double __g, double __b,
	       std::error_code& __ec) noexcept
    : _M_red{__r}, _M_green{__g}, _M_blue{__b}, _M_alpha{1.0}
    { }

    rgba_color(double __r, double __g, double __b, double __a,
	       std::error_code& __ec) noexcept
    : _M_red{__r}, _M_green{__g}, _M_blue{__b}, _M_alpha{__a}
    {
    }

    rgba_color(const rgba_color& __c) noexcept = default;

    rgba_color&
    operator=(const rgba_color& __c) noexcept = default;

    rgba_color(rgba_color&& __c) noexcept = default;

    rgba_color&
    operator=(rgba_color&& __c) noexcept = default;

    // modifiers:

    void
    r(double __val)
    {
      std::error_code __ec;
      this->r(__val);
      if (__ec)
        throw std::someexcept("");
    }

    void
    r(double __val, std::error_code& __ec) noexcept
    {
      ;
    }

    void
    g(double __val)
    {
      std::error_code __ec;
      this->g(__val);
      if (__ec)
        throw std::someexcept("");
    }

    void
    g(double __val, std::error_code& __ec) noexcept
    {
      ;
    }

    void
    b(double __val)
    {
      std::error_code __ec;
      this->b(__val);
      if (__ec)
        throw std::someexcept("");
    }

    void
    b(double __val, std::error_code& __ec) noexcept
    {
      ;
    }

    void
    a(double __val)
    {
      std::error_code __ec;
      this->a(__val);
      if (__ec)
        throw std::someexcept("");
    }

    void
    a(double val, std::error_code& __ec) noexcept
    {
      ;
    }

    // observers:

    double
    r() const noexcept
    { return this->_M_red; }

    double
    g() const noexcept
    { return this->_M_green; }

    double
    b() const noexcept
    { return this->_M_blue; }

    double
    a() const noexcept
    { return this->_M_alpha; }

    // static member functions:

    static const rgba_color&
    alice_blue() noexcept;

    static const rgba_color&
    antique_white() noexcept;

    static const rgba_color&
    aqua() noexcept;

    static const rgba_color&
    aquamarine() noexcept;

    static const rgba_color&
    azure() noexcept;

    static const rgba_color&
    beige() noexcept;

    static const rgba_color&
    bisque() noexcept;

    static const rgba_color&
    black() noexcept;

    static const rgba_color&
    blanched_almond() noexcept;

    static const rgba_color&
    blue() noexcept;

    static const rgba_color&
    blue_violet() noexcept;

    static const rgba_color&
    brown() noexcept;

    static const rgba_color&
    burly_wood() noexcept;

    static const rgba_color&
    cadet_blue() noexcept;

    static const rgba_color&
    chartreuse() noexcept;

    static const rgba_color&
    chocolate() noexcept;

    static const rgba_color&
    coral() noexcept;

    static const rgba_color&
    cornflower_blue() noexcept;

    static const rgba_color&
    cornsilk() noexcept;

    static const rgba_color&
    crimson() noexcept;

    static const rgba_color&
    cyan() noexcept;

    static const rgba_color&
    dark_blue() noexcept;

    static const rgba_color&
    dark_cyan() noexcept;

    static const rgba_color&
    dark_goldenrod() noexcept;

    static const rgba_color&
    dark_gray() noexcept;

    static const rgba_color&
    dark_green() noexcept;

    static const rgba_color&
    dark_grey() noexcept;

    static const rgba_color&
    dark_khaki() noexcept;

    static const rgba_color&
    dark_magenta() noexcept;

    static const rgba_color&
    dark_olive_green() noexcept;

    static const rgba_color&
    dark_orange() noexcept;

    static const rgba_color&
    dark_orchid() noexcept;

    static const rgba_color&
    dark_red() noexcept;

    static const rgba_color&
    dark_salmon() noexcept;

    static const rgba_color&
    dark_sea_green() noexcept;

    static const rgba_color&
    dark_slate_blue() noexcept;

    static const rgba_color&
    dark_slate_gray() noexcept;

    static const rgba_color&
    dark_slate_grey() noexcept;

    static const rgba_color&
    dark_turquoise() noexcept;

    static const rgba_color&
    dark_violet() noexcept;

    static const rgba_color&
    deep_pink() noexcept;

    static const rgba_color&
    deep_sky_blue() noexcept;

    static const rgba_color&
    dim_gray() noexcept;

    static const rgba_color&
    dim_grey() noexcept;

    static const rgba_color&
    dodger_blue() noexcept;

    static const rgba_color&
    firebrick() noexcept;

    static const rgba_color&
    floral_white() noexcept;

    static const rgba_color&
    forest_green() noexcept;

    static const rgba_color&
    fuchsia() noexcept;

    static const rgba_color&
    gainsboro() noexcept;

    static const rgba_color&
    ghost_white() noexcept;

    static const rgba_color&
    gold() noexcept;

    static const rgba_color&
    goldenrod() noexcept;

    static const rgba_color&
    gray() noexcept;

    static const rgba_color&
    green() noexcept;

    static const rgba_color&
    green_yellow() noexcept;

    static const rgba_color&
    grey() noexcept;

    static const rgba_color&
    honeydew() noexcept;

    static const rgba_color&
    hot_pink() noexcept;

    static const rgba_color&
    indian_red() noexcept;

    static const rgba_color&
    indigo() noexcept;

    static const rgba_color&
    ivory() noexcept;

    static const rgba_color&
    khaki() noexcept;

    static const rgba_color&
    lavender() noexcept;

    static const rgba_color&
    lavender_blush() noexcept;

    static const rgba_color&
    lawn_green() noexcept;

    static const rgba_color&
    lemon_chiffon() noexcept;

    static const rgba_color&
    light_blue() noexcept;

    static const rgba_color&
    light_coral() noexcept;

    static const rgba_color&
    light_cyan() noexcept;

    static const rgba_color&
    light_goldenrod_yellow() noexcept;

    static const rgba_color&
    light_gray() noexcept;

    static const rgba_color&
    light_green() noexcept;

    static const rgba_color&
    light_grey() noexcept;

    static const rgba_color&
    light_pink() noexcept;

    static const rgba_color&
    light_salmon() noexcept;

    static const rgba_color&
    light_sea_green() noexcept;

    static const rgba_color&
    light_sky_blue() noexcept;

    static const rgba_color&
    light_slate_gray() noexcept;

    static const rgba_color&
    light_slate_grey() noexcept;

    static const rgba_color&
    light_steel_blue() noexcept;

    static const rgba_color&
    light_yellow() noexcept;

    static const rgba_color&
    lime() noexcept;

    static const rgba_color&
    lime_green() noexcept;

    static const rgba_color&
    linen() noexcept;

    static const rgba_color&
    magenta() noexcept;

    static const rgba_color&
    maroon() noexcept;

    static const rgba_color&
    medium_aquamarine() noexcept;

    static const rgba_color&
    medium_blue() noexcept;

    static const rgba_color&
    medium_orchid() noexcept;

    static const rgba_color&
    medium_purple() noexcept;

    static const rgba_color&
    medium_sea_green() noexcept;

    static const rgba_color&
    medium_slate_blue() noexcept;

    static const rgba_color&
    medium_spring_green() noexcept;

    static const rgba_color&
    medium_turquoise() noexcept;

    static const rgba_color&
    medium_violet_red() noexcept;

    static const rgba_color&
    midnight_blue() noexcept;

    static const rgba_color&
    mint_cream() noexcept;

    static const rgba_color&
    misty_rose() noexcept;

    static const rgba_color&
    moccasin() noexcept;

    static const rgba_color&
    navajo_white() noexcept;

    static const rgba_color&
    navy() noexcept;

    static const rgba_color&
    old_lace() noexcept;

    static const rgba_color&
    olive() noexcept;

    static const rgba_color&
    olive_drab() noexcept;

    static const rgba_color&
    orange() noexcept;

    static const rgba_color&
    orange_red() noexcept;

    static const rgba_color&
    orchid() noexcept;

    static const rgba_color&
    pale_goldenrod() noexcept;

    static const rgba_color&
    pale_green() noexcept;

    static const rgba_color&
    pale_turquoise() noexcept;

    static const rgba_color&
    pale_violet_red() noexcept;

    static const rgba_color&
    papaya_whip() noexcept;

    static const rgba_color&
    peach_puff() noexcept;

    static const rgba_color&
    peru() noexcept;

    static const rgba_color&
    pink() noexcept;

    static const rgba_color&
    plum() noexcept;

    static const rgba_color&
    powder_blue() noexcept;

    static const rgba_color&
    purple() noexcept;

    static const rgba_color&
    red() noexcept;

    static const rgba_color&
    rosy_brown() noexcept;

    static const rgba_color&
    royal_blue() noexcept;

    static const rgba_color&
    saddle_brown() noexcept;

    static const rgba_color&
    salmon() noexcept;

    static const rgba_color&
    sandy_brown() noexcept;

    static const rgba_color&
    sea_green() noexcept;

    static const rgba_color&
    sea_shell() noexcept;

    static const rgba_color&
    sienna() noexcept;

    static const rgba_color&
    silver() noexcept;

    static const rgba_color&
    sky_blue() noexcept;

    static const rgba_color&
    slate_blue() noexcept;

    static const rgba_color&
    slate_gray() noexcept;

    static const rgba_color&
    slate_grey() noexcept;

    static const rgba_color&
    snow() noexcept;

    static const rgba_color&
    spring_green() noexcept;

    static const rgba_color&
    steel_blue() noexcept;

    static const rgba_color&
    tan() noexcept;

    static const rgba_color&
    teal() noexcept;

    static const rgba_color&
    thistle() noexcept;

    static const rgba_color&
    tomato() noexcept;

    static const rgba_color&
    transparent_black() noexcept;

    static const rgba_color&
    turquoise() noexcept;

    static const rgba_color&
    violet() noexcept;

    static const rgba_color&
    wheat() noexcept;

    static const rgba_color&
    white() noexcept;

    static const rgba_color&
    white_smoke() noexcept;

    static const rgba_color&
    yellow() noexcept;

    static const rgba_color&
    yellow_green() noexcept;

  private:

    double _M_red;

    double _M_green;

    double _M_blue;

    double _M_alpha;
  };
  { 240ubyte, 248ubyte, 255ubyte, 255ubyte } // alice_blue
  { 250ubyte, 235ubyte, 215ubyte, 255ubyte } // antique_white
  {   0ubyte, 255ubyte, 255ubyte, 255ubyte } // aqua
  { 127ubyte, 255ubyte, 212ubyte, 255ubyte } // aquamarine
  { 240ubyte, 255ubyte, 255ubyte, 255ubyte } // azure
  { 245ubyte, 245ubyte, 220ubyte, 255ubyte } // beige
  { 255ubyte, 228ubyte, 196ubyte, 255ubyte } // bisque
  {   0ubyte,   0ubyte,   0ubyte, 255ubyte } // black
  { 255ubyte, 235ubyte, 205ubyte, 255ubyte } // blanched_almond
  {   0ubyte,   0ubyte, 255ubyte, 255ubyte } // blue
  { 138ubyte,  43ubyte, 226ubyte, 255ubyte } // blue_violet
  { 165ubyte,  42ubyte,  42ubyte, 255ubyte } // brown
  { 222ubyte, 184ubyte, 135ubyte, 255ubyte } // burly_wood
  {  95ubyte, 158ubyte, 160ubyte, 255ubyte } // cadet_blue
  { 127ubyte, 255ubyte,   0ubyte, 255ubyte } // chartreuse
  { 210ubyte, 105ubyte,  30ubyte, 255ubyte } // chocolate
  { 255ubyte, 127ubyte,  80ubyte, 255ubyte } // coral
  { 100ubyte, 149ubyte, 237ubyte, 255ubyte } // cornflower_blue
  { 255ubyte, 248ubyte, 220ubyte, 255ubyte } // cornsilk
  { 220ubyte,  20ubyte,  60ubyte, 255ubyte } // crimson
  {   0ubyte, 255ubyte, 255ubyte, 255ubyte } // cyan
  {   0ubyte,   0ubyte, 139ubyte, 255ubyte } // dark_blue
  {   0ubyte, 139ubyte, 139ubyte, 255ubyte } // dark_cyan
  { 184ubyte, 134ubyte,  11ubyte, 255ubyte } // dark_goldenrod
  { 169ubyte, 169ubyte, 169ubyte, 255ubyte } // dark_gray
  {   0ubyte, 100ubyte,   0ubyte, 255ubyte } // dark_green
  { 169ubyte, 169ubyte, 169ubyte, 255ubyte } // dark_grey
  { 189ubyte, 183ubyte, 107ubyte, 255ubyte } // dark_khaki
  { 139ubyte,   0ubyte, 139ubyte, 255ubyte } // dark_magenta
  {  85ubyte, 107ubyte,  47ubyte, 255ubyte } // dark_olive_green
  { 255ubyte, 140ubyte,   0ubyte, 255ubyte } // dark_orange
  { 153ubyte,  50ubyte, 204ubyte, 255ubyte } // dark_orchid
  { 139ubyte,   0ubyte,   0ubyte, 255ubyte } // dark_red
  { 233ubyte, 150ubyte, 122ubyte, 255ubyte } // dark_salmon
  { 143ubyte, 188ubyte, 143ubyte, 255ubyte } // dark_sea_green
  {  72ubyte,  61ubyte, 139ubyte, 255ubyte } // dark_slate_blue
  {  47ubyte,  79ubyte,  79ubyte, 255ubyte } // dark_slate_gray
  {  47ubyte,  79ubyte,  79ubyte, 255ubyte } // dark_slate_grey
  {   0ubyte, 206ubyte, 209ubyte, 255ubyte } // dark_turquoise
  { 148ubyte,   0ubyte, 211ubyte, 255ubyte } // dark_violet
  { 255ubyte,  20ubyte, 147ubyte, 255ubyte } // deep_pink
  {   0ubyte, 191ubyte, 255ubyte, 255ubyte } // deep_sky_blue
  { 105ubyte, 105ubyte, 105ubyte, 255ubyte } // dim_gray
  { 105ubyte, 105ubyte, 105ubyte, 255ubyte } // dim_grey
  {  30ubyte, 144ubyte, 255ubyte, 255ubyte } // dodger_blue
  { 178ubyte, 34ubyte,   34ubyte, 255ubyte } // firebrick
  { 255ubyte, 250ubyte, 240ubyte, 255ubyte } // floral_white
  {  34ubyte, 139ubyte,  34ubyte, 255ubyte } // forest_green
  { 255ubyte,   0ubyte, 255ubyte, 255ubyte } // fuchsia
  { 220ubyte, 220ubyte, 220ubyte, 255ubyte } // gainsboro
  { 248ubyte, 248ubyte, 255ubyte, 255ubyte } // ghost_white
  { 255ubyte, 215ubyte,   0ubyte, 255ubyte } // gold
  { 218ubyte, 165ubyte,  32ubyte, 255ubyte } // goldenrod
  { 128ubyte, 128ubyte, 128ubyte, 255ubyte } // gray
  {   0ubyte, 128ubyte,   0ubyte, 255ubyte } // green
  { 173ubyte, 255ubyte,  47ubyte, 255ubyte } // green_yellow
  { 128ubyte, 128ubyte, 128ubyte, 255ubyte } // grey
  { 240ubyte, 255ubyte, 240ubyte, 255ubyte } // honeydew
  { 255ubyte, 105ubyte, 180ubyte, 255ubyte } // hot_pink
  { 205ubyte,  92ubyte,  92ubyte, 255ubyte } // indian_red
  { 75ubyte,    0ubyte, 130ubyte, 255ubyte } // indigo
  { 255ubyte, 255ubyte, 240ubyte, 255ubyte } // ivory
  { 240ubyte, 230ubyte, 140ubyte, 255ubyte } // khaki
  { 230ubyte, 230ubyte, 250ubyte, 255ubyte } // lavender
  { 255ubyte, 240ubyte, 245ubyte, 255ubyte } // lavender_blush
  { 124ubyte, 252ubyte,   0ubyte, 255ubyte } // lawn_green
  { 255ubyte, 250ubyte, 205ubyte, 255ubyte } // lemon_chiffon
  { 173ubyte, 216ubyte, 230ubyte, 255ubyte } // light_blue
  { 240ubyte, 128ubyte, 128ubyte, 255ubyte } // light_coral
  { 224ubyte, 255ubyte, 255ubyte, 255ubyte } // light_cyan
  { 250ubyte, 250ubyte, 210ubyte, 255ubyte } // light_goldenrod_yellow
  { 211ubyte, 211ubyte, 211ubyte, 255ubyte } // light_gray
  { 144ubyte, 238ubyte, 144ubyte, 255ubyte } // light_green
  { 211ubyte, 211ubyte, 211ubyte, 255ubyte } // light_grey
  { 255ubyte, 182ubyte, 193ubyte, 255ubyte } // light_pink
  { 255ubyte, 160ubyte, 122ubyte, 255ubyte } // light_salmon
  {  32ubyte, 178ubyte, 170ubyte, 255ubyte } // light_sea_green
  { 135ubyte, 206ubyte, 250ubyte, 255ubyte } // light_sky_blue
  { 119ubyte, 136ubyte, 153ubyte, 255ubyte } // light_slate_gray
  { 119ubyte, 136ubyte, 153ubyte, 255ubyte } // light_slate_grey
  { 176ubyte, 196ubyte, 222ubyte, 255ubyte } // light_steel_blue
  { 255ubyte, 255ubyte, 224ubyte, 255ubyte } // light_yellow
  {   0ubyte, 255ubyte,   0ubyte, 255ubyte } // lime
  {  50ubyte, 205ubyte,  50ubyte, 255ubyte } // lime_green
  { 250ubyte, 240ubyte, 230ubyte, 255ubyte } // linen
  { 255ubyte,   0ubyte, 255ubyte, 255ubyte } // magenta
  { 128ubyte,   0ubyte,   0ubyte, 255ubyte } // maroon
  { 102ubyte, 205ubyte, 170ubyte, 255ubyte } // medium_aquamarine
  {   0ubyte,   0ubyte, 205ubyte, 255ubyte } // medium_blue
  { 186ubyte,  85ubyte, 211ubyte, 255ubyte } // medium_orchid
  { 147ubyte, 112ubyte, 219ubyte, 255ubyte } // medium_purple
  {  60ubyte, 179ubyte, 113ubyte, 255ubyte } // medium_sea_green
  { 123ubyte, 104ubyte, 238ubyte, 255ubyte } // medium_slate_blue
  {   0ubyte, 250ubyte, 154ubyte, 255ubyte } // medium_spring_green
  {  72ubyte, 209ubyte, 204ubyte, 255ubyte } // medium_turquoise
  { 199ubyte,  21ubyte, 133ubyte, 255ubyte } // medium_violet_red
  {  25ubyte,  25ubyte, 112ubyte, 255ubyte } // midnight_blue
  { 245ubyte, 255ubyte, 250ubyte, 255ubyte } // mint_cream
  { 255ubyte, 228ubyte, 225ubyte, 255ubyte } // misty_rose
  { 255ubyte, 228ubyte, 181ubyte, 255ubyte } // moccasin
  { 255ubyte, 222ubyte, 173ubyte, 255ubyte } // navajo_white
  {   0ubyte,   0ubyte, 128ubyte, 255ubyte } // navy
  { 253ubyte, 245ubyte, 230ubyte, 255ubyte } // old_lace
  { 128ubyte, 128ubyte,   0ubyte, 255ubyte } // olive
  { 107ubyte, 142ubyte,  35ubyte, 255ubyte } // olive_drab
  { 255ubyte, 165ubyte,   0ubyte, 255ubyte } // orange
  { 255ubyte,  69ubyte,   0ubyte, 255ubyte } // orange_red
  { 218ubyte, 112ubyte, 214ubyte, 255ubyte } // orchid
  { 238ubyte, 232ubyte, 170ubyte, 255ubyte } // pale_goldenrod
  { 152ubyte, 251ubyte, 152ubyte, 255ubyte } // pale_green
  { 175ubyte, 238ubyte, 238ubyte, 255ubyte } // pale_turquoise
  { 219ubyte, 112ubyte, 147ubyte, 255ubyte } // pale_violet_red
  { 255ubyte, 239ubyte, 213ubyte, 255ubyte } // papaya_whip
  { 255ubyte, 218ubyte, 185ubyte, 255ubyte } // peach_puff
  { 205ubyte, 133ubyte,  63ubyte, 255ubyte } // peru
  { 255ubyte, 192ubyte, 203ubyte, 255ubyte } // pink
  { 221ubyte, 160ubyte, 221ubyte, 255ubyte } // plum
  { 176ubyte, 224ubyte, 230ubyte, 255ubyte } // powder_blue
  { 128ubyte,   0ubyte, 128ubyte, 255ubyte } // purple
  { 255ubyte,   0ubyte,   0ubyte, 255ubyte } // red
  { 188ubyte, 143ubyte, 143ubyte, 255ubyte } // rosy_brown
  {  65ubyte, 105ubyte, 225ubyte, 255ubyte } // royal_blue
  { 139ubyte,  69ubyte,  19ubyte, 255ubyte } // saddle_brown
  { 250ubyte, 128ubyte, 114ubyte, 255ubyte } // salmon
  { 244ubyte, 164ubyte,  96ubyte, 255ubyte } // sandy_brown
  {  46ubyte, 139ubyte,  87ubyte, 255ubyte } // sea_green
  { 255ubyte, 245ubyte, 238ubyte, 255ubyte } // sea_shell
  { 160ubyte,  82ubyte,  45ubyte, 255ubyte } // sienna
  { 192ubyte, 192ubyte, 192ubyte, 255ubyte } // silver
  { 135ubyte, 206ubyte, 235ubyte, 255ubyte } // sky_blue
  { 106ubyte, 90ubyte, 205ubyte, 255ubyte } // slate_blue
  { 112ubyte, 128ubyte, 144ubyte, 255ubyte } // slate_gray
  { 112ubyte, 128ubyte, 144ubyte, 255ubyte } // slate_grey
  { 255ubyte, 250ubyte, 250ubyte, 255ubyte } // snow
  {   0ubyte, 255ubyte, 127ubyte, 255ubyte } // spring_green
  {  70ubyte, 130ubyte, 180ubyte, 255ubyte } // steel_blue
  { 210ubyte, 180ubyte, 140ubyte, 255ubyte } // tan
  {   0ubyte, 128ubyte, 128ubyte, 255ubyte } // teal
  { 216ubyte, 191ubyte, 216ubyte, 255ubyte } // thistle
  { 255ubyte,  99ubyte,  71ubyte, 255ubyte } // tomato
  {   0ubyte,   0ubyte,   0ubyte,   0ubyte } // transparent_black
  {  64ubyte, 244ubyte, 208ubyte, 255ubyte } // turquoise
  { 238ubyte, 130ubyte, 238ubyte, 255ubyte } // violet
  { 245ubyte, 222ubyte, 179ubyte, 255ubyte } // wheat
  { 255ubyte, 255ubyte, 255ubyte, 255ubyte } // white
  { 245ubyte, 245ubyte, 245ubyte, 255ubyte } // white_smoke
  { 255ubyte, 255ubyte,   0ubyte, 255ubyte } // yellow
  { 154ubyte, 205ubyte,  50ubyte, 255ubyte } // yellow_green


  // non-member operators:

  bool
  operator==(const rgba_color& __lhs, const rgba_color& __rhs) noexcept
  {
    return __lhs.r() = __rhs.r()
        && __lhs.g() = __rhs.g()
        && __lhs.b() = __rhs.b()
        && __lhs.a() = __rhs.a();
  }

  bool
  operator!=(const rgba_color& __lhs, const rgba_color& __rhs) noexcept
  { return !(__lhs == __rhs); }

inline namespace literals
{
  // N.B. a std::clamp would be useful here.
  /**
   * 
   */
  double
  operator""ubyte(unsigned long long int __val)
  { std::max(0.0, std::min(1.0, static_cast<double>(__val) / 255.0)); }

  /**
   * 
   */
  double
  operator""unorm(long double __val)
  { std::nearbyint(std::max(0.0, std::min(1.0, static_cast<double>(__val))) * 255.0) / 255.0; }

} // inline namespace literals

  /**
   * 
   */
  class vector_2d
  {
  public:

    // construct/copy/move/destroy:

    vector_2d() noexcept
    : _M_x{}, _M_y{}
    { }

    vector_2d(double __x, double __y) noexcept
    : _M_x{__x}, _M_y{__y}
    { }

    vector_2d(const vector_2d& __vec) noexcept
    : _M_x{__vec._M_x}, _M_y{__vec._M_y}
    { }

    vector_2d&
    operator=(const vector_2d& __vec) noexcept
    {
      this->_M_x = __vec._M_x;
      this->_M_y = __vec._M_y;
      return *this;
    }

    vector_2d(vector_2d&& __vec) noexcept
    : _M_x{__vec._M_x}, _M_y{__vec._M_y}
    { }

    vector_2d&
    operator=(vector_2d&& __vec) noexcept
    {
      this->_M_x = __vec._M_x;
      this->_M_y = __vec._M_y;
      return *this;
    }

    // modifiers:

    void
    x(double __value) noexcept
    { this->_M_x = __value; }

    void
    y(double __value) noexcept
    { this->_M_y = __value; }

    // 7.5, observers:

    double
    x() const noexcept
    { return this->_M_x; }
 
    double
    y() const noexcept
    { return this->_M_y; }

    double
    length() const noexcept
    { return std::hypot(this->_M_x, this->_M_y); }

    double
    dot(const vector_2d& __vec) const noexcept
    { return this->_M_x * __vec._M_x + this->_M_y * __vec._M_y; }

    vector_2d
    to_unit() const noexcept
    {
      auto __len = std::hypot(this->_M_x, this->_M_y);
      return vector_2d{this->_M_x / __len, this->_M_y / __len};
    }

    // member operators:

    vector_2d&
    operator+=(const vector_2d& __rhs) noexcept
    {
      this->_M_x += __rhs._M_x;
      this->_M_y += __rhs._M_y;
      return *this;
    }

    vector_2d&
    operator-=(const vector_2d& __rhs) noexcept
    {
      this->_M_x -= __rhs._M_x;
      this->_M_y -= __rhs._M_y;
      return *this;
    }

    vector_2d&
    operator*=(double __rhs) noexcept
    {
      this->_M_x *= __rhs;
      this->_M_y *= __rhs;
      return *this;
    }

  private:

    double _M_x;
    double _M_y;
  };

  // non-member operators:

  inline bool
  operator==(const vector_2d& __lhs, const vector_2d& __rhs) noexcept
  { return __lhs.x() == __rhs.x() && __lhs.y() == __rhs.y(); }

  inline bool
  operator!=(const vector_2d& __lhs, const vector_2d& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline vector_2d
  operator+(const vector_2d& __lhs) noexcept
  { return __lhs; }

  inline vector_2d
  operator+(const vector_2d& __lhs, const vector_2d& __rhs) noexcept
  {
    auto __ret{__lhs};
    __ret += __rhs;
    return __ret;
  }

  inline vector_2d
  operator-(const vector_2d& __lhs) noexcept
  { return vector_2d{-__lhs.x(), -__lhs.y()}; }

  inline vector_2d
  operator-(const vector_2d& __lhs, const vector_2d& __rhs) noexcept
  {
    auto __ret{__lhs};
    __ret -= __rhs;
    return __ret;
  }

  inline vector_2d
  operator*(const vector_2d& __lhs, double __rhs) noexcept
  { return vector_2d{__rhs * __lhs.x(), __rhs * __lhs.y()}; }

  inline vector_2d
  operator*(double __lhs, const vector_2d& __rhs) noexcept
  { return vector_2d{__lhs * __rhs.x(), __lhs * __rhs.y()}; }

  /**
   *
   */
  class rectangle
  {
  public:

    // construct/copy/move/destroy:

    rectangle() noexcept = default;

    rectangle(double __x, double __y, double __width, double __height) noexcept
    : _M_x{__x}, _M_y{__y},
      _M_width{__width}, _M_height{__height}
    { }

    rectangle(const vector_2d& __tl, const vector_2d& __br) noexcept
    : _M_x{__tl.x()}, _M_y{__tl.y()},
      _M_width{__br.x() - __tl.x()}, _M_height{__br.y() - __tl.y()}
    { }

    rectangle(const rectangle&) noexcept = default;

    rectangle&
    operator=(const rectangle&) noexcept = default;

    rectangle(rectangle&&) noexcept = default;

    rectangle&
    operator=(rectangle&&) noexcept = default;

    // modifiers:

    void
    x(double __x) noexcept
    { this->_M_x = __x; }

    void
    y(double __y) noexcept
    { this->_M_y = __y; }

    void
    width(double __width) noexcept
    { this->_M_width = __width; }

    void
    height(double __height) noexcept
    { this->_M_height = __height; }

    void
    top_left(const vector_2d& __tl) noexcept
    {
      this->_M_x = __tl.x();
      this->_M_y = __tl.y();
    }

    void
    bottom_right(const vector_2d& __br) noexcept
    {
      this->_M_width = __br.x() - this->_M_x;
      this->_M_height = __br.y() - this->_M_y;
    }


    // observers:

    double
    x() const noexcept
    { return this->_M_x; }

    double
    y() const noexcept
    { return this->_M_y; }

    double
    width() const noexcept
    { return this->_M_width; }

    double
    height() const noexcept
    { return this->_M_height; }

    vector_2d
    top_left() const noexcept
    { return vector_2d{this->x(), this->y()}; }

    vector_2d
    bottom_right() const noexcept
    {
      return vector_2d{this->x() + this->width(),
		       this->y() + this->height()};
    }

  private:

    double _M_x;

    double _M_y;

    double _M_width;

    double _M_height;
  };

  /**
   *
   */
  class matrix_2d
  {
  public:

    // construct/copy/move/destroy:

    matrix_2d() noexcept
    : _M00{}, _M01{},
      _M10{}, _M11{},
      _M20{}, _M21{}
    { }

    matrix_2d(const matrix_2d&) noexcept = default;

    matrix_2d&
    operator=(const matrix_2d&) noexcept = default;

    matrix_2d(matrix_2d&&) noexcept = default;

    matrix_2d&
    operator=(matrix_2d&&) noexcept = default;

    matrix_2d(double __v00, double __v01, double __v10, double __v11,
	      double __v20, double __v21) noexcept
    : _M00{__v00}, _M01{__v01},
      _M10{__v10}, _M11{__v11},
      _M20{__v20}, _M21{__v21}
    { }

    // static factory functions:

    static matrix_2d
    init_identity() noexcept
    {
      matrix_2d __mat;
      __mat._M00 = 1.0;
      __mat._M11 = 1.0;
      return __mat;
    }

    static matrix_2d
    init_translate(const vector_2d& __delta) noexcept
    { return matrix_2d{0.0, 0.0, 0.0, 0.0, __delta.x(), __delta.y()}; }

    static matrix_2d
    init_scale(const vector_2d& __scale) noexcept
    { return matrix_2d{__scale.x(), 0.0, 0.0, __scale.y(), 0.0, 0.0}; }

    static matrix_2d
    init_rotate(double __radians) noexcept
    {
      auto __cos = std::cos(__radians);
      auto __sin = std::sin(__radians);
      return matrix_2d{__cos, __sin, -__sin, __cos, 0.0, 0.0};
    }

    static matrix_2d
    init_shear_x(double __shear_x) noexcept
    { return matrix_2d{1.0, 0.0, __shear_x, 1.0, 0.0, 0.0}; }

    static matrix_2d
    init_shear_y(double __shear_y) noexcept
    { return matrix_2d{1.0, __shear_y, 0.0, 1.0, 0.0, 0.0}; }

    // modifiers:

    void
    m00(double __v00) noexcept
    { this->_M00 = __v00; }

    void
    m01(double __v01) noexcept
    { this->_M01 = __v01; }

    void
    m10(double __v10) noexcept
    { this->_M10 = __v10; }

    void
    m11(double __v11) noexcept
    { this->_M11 = __v11; }

    void
    m20(double __v20) noexcept
    { this->_M20 = __v20; }

    void
    m21(double __v21) noexcept
    { this->_M21 = __v21; }

    matrix_2d&
    translate(const vector_2d& __value) noexcept
    {
      return *this;
    }

    matrix_2d&
    scale(const vector_2d& __value) noexcept
    {
      return *this;
    }

    matrix_2d&
    rotate(double __radians) noexcept
    {
      return *this;
    }

    matrix_2d&
    shear_x(double __factor) noexcept
    {
      return *this;
    }

    matrix_2d&
    shear_y(double __factor) noexcept
    {
      return *this;
    }

    matrix_2d&
    invert()
    {
      std::error_code __ec;
      this->invert(__ec);
      if (__ec)
	throw std::someexcept();
      return *this;
    }

    matrix_2d&
    invert(std::error_code& __ec) noexcept
    {
      __ec.clear();
      auto __det = this->determinant(__ec);
      return *this;
    }

    // observers:

    double
    m00() const noexcept
    { return this->_M00; }

    double
    m01() const noexcept
    { return this->_M01; }

    double
    m10() const noexcept
    { return this->_M10; }

    double
    m11() const noexcept
    { return this->_M11; }

    double
    m20() const noexcept
    { return this->_M20; }

    double
    m21() const noexcept
    { return this->_M21; }

    bool
    is_invertible() const noexcept
    {
      constexpr auto _S_min = 100.0 * std::numeric_limits<double>::min();

      return std::isfinite(this->_M00) && std::isfinite(this->_M01)
	  && std::isfinite(this->_M10) && std::isfinite(this->_M11)
	  && std::isfinite(this->_M20) && std::isfinite(this->_M21)
	  && std::abs(this->determinant()) > _S_min;
    }

    double
    determinant() const
    {
      std::error_code __ec;
      auto __det = this->determinant(__ec);
      if (__ec)
	throw std::someexcept();
      return __det;
    }

    double
    determinant(std::error_code& __ec) const noexcept
    {
      __ec.clear();
      auto __det = this->_M00 * this->_M11 - this->_M01 * this->_M10;
      return __det;
    }

    vector_2d
    transform_distance(const vector_2d& __dist) const noexcept;

    vector_2d
    transform_point(const vector_2d& __pt) const noexcept;

    // matrix_2d member operators:

    matrix_2d&
    operator*=(const matrix_2d& __rhs) noexcept;

  private:

    double _M00;

    double _M01;

    double _M10;

    double _M11;

    double _M20;

    double _M21;
  };

  // matrix_2d non-member operators:

  matrix_2d
  operator*(const matrix_2d& __lhs, const matrix_2d& __rhs) noexcept
  {
    return matrix_2d
      {
	__lhs.m00() * __rhs.m00() + __lhs.m01() * __rhs.m10(),
	__lhs.m00() * __rhs.m01() + __lhs.m01() * __rhs.m11(),
	__lhs.m10() * __rhs.m00() + __lhs.m11() * __rhs.m10(),
	__lhs.m10() * __rhs.m01() + __lhs.m11() * __rhs.m11(),
	__lhs.m20() * __rhs.m00() + __lhs.m21() * __rhs.m10() + __lhs.m20(),
	__lhs.m20() * __rhs.m01() + __lhs.m21() * __rhs.m11() + __lhs.m21()
      };
  }

  bool
  operator==(const matrix_2d& __lhs, const matrix_2d& __rhs) noexcept
  {
    return __lhs.m00() == __rhs.m00()
	&& __lhs.m01() == __rhs.m01()
	&& __lhs.m10() == __rhs.m10()
	&& __lhs.m11() == __rhs.m11()
	&& __lhs.m20() == __rhs.m20()
	&& __lhs.m21() == __rhs.m21();
  }

  bool
  operator!=(const matrix_2d& __lhs, const matrix_2d& __rhs) noexcept
  { return !(__lhs == __rhs); }

  /**
   *
   */
  enum class path_data_type
  {
    move_to,
    line_to,
    curve_to,
    new_sub_path,
    close_path,
    rel_move_to,
    rel_line_to,
    rel_curve_to,
    arc,
    arc_negative,
    change_matrix,
    change_origin
  };

  /**
   *
   */
  class path_data_item
  {
  public:

    class path_data;
    class arc;
    class arc_negative;
    class change_matrix;
    class change_origin;
    class close_path;
    class curve_to;
    class line_to;
    class move_to;
    class new_sub_path;
    class rel_curve_to;
    class rel_line_to;
    class rel_move_to;

    // construct/copy/move/destroy:

    path_data_item() noexcept
    : _M_has_data{false}
    { }

    path_data_item(const path_data_item& __other) noexcept = default;

    path_data_item&
    operator=(const path_data_item& __other) noexcept = default;

    path_data_item(path_data_item&& __other) noexcept = default;

    path_data_item&
    operator=(path_data_item&& __other) noexcept = default;

    path_data_item(const path_data_item::arc& __val) noexcept
    : _M_has_data{true},
      _M_data.arc._M_center_x{__val.center().x()},
      _M_data.arc._M_center_y{__val.center().y()},
      _M_data.arc._M_radius{__val.radius()},
      _M_data.arc._M_angle1{__val.angle_1()},
      _M_data.arc._M_angle2{__val.angle_2()},
      _M_type{path_data_type::arc}
    { }

    path_data_item(const path_data_item::arc_negative& __val) noexcept
    : _M_has_data{true},
      _M_data.arc._M_center_x{__val.center().x()},
      _M_data.arc._M_center_y{__val.center().y()},
      _M_data.arc._M_radius{__val.radius()},
      _M_data.arc._M_angle1{__val.angle_1()},
      _M_data.arc._M_angle2{__val.angle_2()},
      _M_type{path_data_type::arc_negative}
    { }

    path_data_item(const path_data_item::change_matrix& __val) noexcept
    : _M_has_data{true},
      _M_data.matrix._M_m00{__val.matrix().m00()},
      _M_data.matrix._M_m01{__val.matrix().m01()},
      _M_data.matrix._M_m10{__val.matrix().m10()},
      _M_data.matrix._M_m11{__val.matrix().m11()},
      _M_data.matrix._M_m20{__val.matrix().m20()},
      _M_data.matrix._M_m21{__val.matrix().m21()},
      _M_type{path_data_type::change_matrix}
    { }

    path_data_item(const path_data_item::change_origin& __val) noexcept
    : _M_has_data{true},
      _M_data.point._M_x{__val.origin().x()},
      _M_data.point._M_y{__val.origin().y()},
      _M_type{path_data_type::change_origin}
    { }

    path_data_item(const path_data_item::close_path& __val) noexcept
    : _M_has_data{true},
      _M_type{path_data_type::close_path}
    { }

    path_data_item(const path_data_item::curve_to& __val) noexcept
    : _M_has_data{true},
      _M_data.curve._M_crvpt1_x{__val.control_point_1().x()},
      _M_data.curve._M_crvpt1_y{__val.control_point_1().y()},
      _M_data.curve._M_crvpt2_x{__val.control_point_2().x()},
      _M_data.curve._M_crvpt2_y{__val.control_point_2().y()},
      _M_data.curve._M_endpt_x{__val.end_point().x()},
      _M_data.curve._M_endpt_y{__val.end_point().y()},
      _M_type{path_data_type::curve_to}
    { }

    path_data_item(const path_data_item::rel_curve_to& __val) noexcept
    : _M_has_data{true},
      _M_data.curve._M_crvpt1_x{__val.control_point_1().x()},
      _M_data.curve._M_crvpt1_y{__val.control_point_1().y()},
      _M_data.curve._M_crvpt2_x{__val.control_point_2().x()},
      _M_data.curve._M_crvpt2_y{__val.control_point_2().y()},
      _M_data.curve._M_endpt_x{__val.end_point().x()},
      _M_data.curve._M_endpt_y{__val.end_point().y()},
      _M_type{path_data_type::rel_curve_to}
    { }

    path_data_item(const path_data_item::new_sub_path& __val) noexcept
    : _M_has_data{true},
      _M_type{path_data_type::new_sub_path}
    { }

    path_data_item(const path_data_item::line_to& __val) noexcept
    : _M_has_data{true},
      _M_data.point._M_x{__val.to().x()},
      _M_data.point._M_y{__val.to().y()},
      _M_type{path_data_type::line_to}
    { }

    path_data_item(const path_data_item::move_to& __val) noexcept
    : _M_has_data{true},
      _M_data.point._M_x{__val.to().x()},
      _M_data.point._M_y{__val.to().y()},
      _M_type{path_data_type::move_to}
    { }

    path_data_item(const path_data_item::rel_line_to& __val) noexcept
    : _M_has_data{true},
      _M_data.point._M_x{__val.to().x()},
      _M_data.point._M_y{__val.to().y()},
      _M_type{path_data_type::rel_line_to}
    { }

    path_data_item(const path_data_item::rel_move_to& __val) noexcept
    : _M_has_data{true},
      _M_data.point._M_x{__val.to().x()},
      _M_data.point._M_y{__val.to().y()},
      _M_type{path_data_type::rel_move_to}
    { }

    // modifiers:

    void
    assign(const path_data_item::arc& __val) noexcept
    {
      this->_M_has_data = true;
      this->_M_data.arc._M_center_x = __val.center().x();
      this->_M_data.arc._M_center_y = __val.center().y();
      this->_M_data.arc._M_radius = __val.radius();
      this->_M_data.arc._M_angle1 = __val.angle_1();
      this->_M_data.arc._M_angle2 = __val.angle_2();
      this->_M_type = path_data_type::arc;
    }

    void
    assign(const path_data_item::arc_negative& __val) noexcept
    {
      this->_M_has_data = true;
      this->_M_data.arc._M_center_x = __val.center().x();
      this->_M_data.arc._M_center_y = __val.center().y();
      this->_M_data.arc._M_radius = __val.radius();
      this->_M_data.arc._M_angle1 = __val.angle_1();
      this->_M_data.arc._M_angle2 = __val.angle_2();
      this->_M_type = path_data_type::arc_negative;
    }

    void
    assign(const path_data_item::change_matrix& __val) noexcept
    {
      this->_M_has_data = true;
      this->_M_data.matrix._M_m00 = __val.matrix().m00();
      this->_M_data.matrix._M_m01 = __val.matrix().m01();
      this->_M_data.matrix._M_m10 = __val.matrix().m10();
      this->_M_data.matrix._M_m11 = __val.matrix().m11();
      this->_M_data.matrix._M_m20 = __val.matrix().m20();
      this->_M_data.matrix._M_m21 = __val.matrix().m21();
      this->_M_type = path_data_type::change_matrix;
    }

    void
    assign(const path_data_item::change_origin& __val) noexcept
    {
      this->_M_has_data = true;
      this->_M_data.point._M_x = __val.origin().x();
      this->_M_data.point._M_y = __val.origin().y();
      this->_M_type = path_data_type::change_origin;
    }

    void
    assign(const path_data_item::close_path& __val) noexcept
    {
      this->_M_has_data = true;
      this->_M_type = path_data_type::close_path;
    }

    void
    assign(const path_data_item::curve_to& __val) noexcept
    {
      this->_M_has_data = true;
      this->_M_data.curve._M_crvpt1_x = __val.control_point_1().x();
      this->_M_data.curve._M_crvpt1_y = __val.control_point_1().y();
      this->_M_data.curve._M_crvpt2_x = __val.control_point_2().x();
      this->_M_data.curve._M_crvpt2_y = __val.control_point_2().y();
      this->_M_data.curve._M_endpt_x = __val.end_point().x();
      this->_M_data.curve._M_endpt_y = __val.end_point().y();
      this->_M_type = path_data_type::curve_to;
    }

    void
    assign(const path_data_item::rel_curve_to& __val) noexcept
    {
      this->_M_has_data = true;
      this->_M_data.curve._M_crvpt1_x = __val.control_point_1().x();
      this->_M_data.curve._M_crvpt1_y = __val.control_point_1().y();
      this->_M_data.curve._M_crvpt2_x = __val.control_point_2().x();
      this->_M_data.curve._M_crvpt2_y = __val.control_point_2().y();
      this->_M_data.curve._M_endpt_x = __val.end_point().x();
      this->_M_data.curve._M_endpt_y = __val.end_point().y();
      this->_M_type = path_data_type::rel_curve_to;
    }

    void
    assign(const path_data_item::new_sub_path& __val) noexcept
    {
      this->_M_has_data = true;
      this->_M_type = path_data_type::new_sub_path;
    }

    void
    assign(const path_data_item::line_to& __val) noexcept
    {
      this->_M_has_data = true;
      this->_M_data.point._M_x = __val.to().x();
      this->_M_data.point._M_y = __val.to().y();
      this->_M_type = path_data_type::line_to;
    }

    void
    assign(const path_data_item::move_to& __val) noexcept
    {
      this->_M_has_data = true;
      this->_M_data.point._M_x = __val.to().x();
      this->_M_data.point._M_y = __val.to().y();
      this->_M_type = path_data_type::move_to;
    }

    void
    assign(const path_data_item::rel_line_to& __val) noexcept
    {
      this->_M_has_data = true;
      this->_M_data.point._M_x = __val.to().x();
      this->_M_data.point._M_y = __val.to().y();
      this->_M_type = path_data_type::rel_line_to;
    }

    void
    assign(const path_data_item::rel_move_to& __val) noexcept
    {
      this->_M_has_data = true;
      this->_M_data.point._M_x = __val.to().x();
      this->_M_data.point._M_y = __val.to().y();
      this->_M_type = path_data_type::rel_move_to;
    }

    // observers:

    bool
    has_data() const noexcept
    { return this->_M_has_data; }

    path_data_type
    type() const
    { return this->_M_type; }

    path_data_type
    type(std::error_code& __ec) const noexcept
    { return static_cast<path_data_item>(-1); } // FIXME

    template<typename _Tp>
      _Tp
      get() const;

    template<typename _Tp>
      _Tp
      get(std::error_code& __ec) const noexcept;

  private:

    bool _M_has_data;

    union
    {
      struct
      {
	double _M_center_x;
	double _M_center_y;
	double _M_radius;
	double _M_angle1;
	double _M_angle2;
      }
      arc;

      struct
      {
	double _M_m00;
	double _M_m01;
	double _M_m10;
	double _M_m11;
	double _M_m20;
	double _M_m21;
      }
      matrix;

      struct
      {
	double _M_crvpt1_x;
	double _M_crvpt1_y;
	double _M_crvpt2_x;
	double _M_crvpt2_y;
	double _M_endpt_x;
	double _M_endpt_y;
      }
      curve;

      struct
      {
	double _M_x;
	double _M_y;
      }
      point;
    }
    _M_data;

    path_data_type _M_type;
  };

  /**
   *
   */
  class path_data_item::arc_negative
  : public path_data_item::path_data
  {
  public:

    // construct/copy/move/destroy:

    arc_negative() noexcept = default;

    arc_negative(const arc_negative& __arc) noexcept = default;

    path_data_item::arc_negative&
    operator=(const arc_negative& __arc) noexcept = default;

    arc_negative(arc_negative&&) noexcept = default;

    path_data_item::arc_negative&
    operator=(arc_negative&&) noexcept = default;

    arc_negative(const vector_2d& __center, double __radius,
		 double __angle_1, double __angle_2) noexcept
    : _M_center{__center}, _M_radius{__radius},
      _M_angle_1{__angle_1}, _M_angle_2{__angle_2}
    { }

    // modifiers:

    void
    center(const vector_2d& __center) noexcept
    { this->_M_center = __center; }

    void
    radius(double __radius) noexcept
    { this->_M_radius = __radius; }

    void
    angle_1(double __angle_1) noexcept
    { this->_M_angle_1 = __angle_1; }

    void
    angle_2(double __angle_2) noexcept
    { this->_M_angle_2 = __angle_2; }

    // observers:

    vector_2d
    center() const noexcept
    { return this->_M_center; }

    double
    radius() const noexcept
    { return this->_M_radius; }

    double
    angle_1() const noexcept
    { return this->_M_angle_1; }

    double
    angle_2() const noexcept
    { return this->_M_angle_2; }

    virtual path_data_type
    type() const noexcept override
    { return path_data_type::arc_negative; }

  private:

    vector_2d _M_center;

    double _M_radius;

    double _M_angle_1;

    double _M_angle_2;
  };

  /**
   *
   */
  class path_data_item::close_path
  : public path_data_item::path_data
  {
  public:

    // construct/copy/move/destroy:

    close_path() noexcept = default;

    close_path(const close_path&) noexcept = default;

    path_data_item::close_path&
    operator=(const close_path&) noexcept = default;

    close_path(close_path&&) noexcept = default;

    path_data_item::close_path&
    operator=(close_path&&) noexcept = default;

    // observers:

    virtual path_data_type
    type() const noexcept override
    { return path_data_type::close_path; }
  };

  /**
   *
   */
  class path_data_item::change_matrix
  : public path_data_item::path_data
  {
  public:

    // construct/copy/move/destroy:

    change_matrix() noexcept = default;

    change_matrix(const change_matrix&) noexcept = default;

    path_data_item::change_matrix&
    operator=(const change_matrix&) noexcept = default;

    change_matrix(change_matrix&&) noexcept = default;

    path_data_item::change_matrix&
    operator=(change_matrix&&) noexcept = default;

    explicit
    change_matrix(const matrix_2d& __mat) noexcept
    : _M_matrix{__mat}
    { }

    // modifiers:

    void
    matrix(const matrix_2d& __mat) noexcept
    { this->_M_matrix = __mat; }

    // observers:

    matrix_2d
    matrix() const noexcept
    { return this->_M_matrix; }

    virtual path_data_type
    type() const noexcept override
    { return path_data_type::change_matrix; }

  private:

    matrix_2d _M_matrix;
  };

  /**
   *
   */
  class path_data_item::change_origin
  : public path_data_item::path_data
  {
  public:

    // construct/copy/move/destroy:

    change_origin() noexcept = default;

    change_origin(const change_origin&) noexcept = default;

    path_data_item::change_origin&
    operator=(const change_origin&) noexcept = default;

    change_origin(change_origin&&) noexcept = default;

    path_data_item::change_origin&
    operator=(change_origin&&) noexcept = default;

    explicit
    change_origin(const vector_2d& __pt) noexcept
    : _M_origin{__pt}
    { }

    // modifiers:

    void
    origin(const vector_2d& __pt) noexcept;

    // observers:

    vector_2d
    origin() const noexcept
    { return this->_M_origin; }

    virtual path_data_type
    type() const noexcept override
    { return path_data_type::change_origin; }

  private:

    vector_2d _M_origin;
  };

  /**
   *
   */
  class path_data_item::curve_to
  : public path_data_item::path_data
  {
  public:

    // construct/copy/move/destroy:

    curve_to() noexcept = default;

    curve_to(const curve_to&) noexcept = default;

    path_data_item::curve_to&
    operator=(const curve_to&) noexcept = default;

    curve_to(curve_to&&) noexcept = default;

    path_data_item::curve_to&
    operator=(curve_to&&) noexcept = default;

    curve_to(const vector_2d& __ctrl_pt1,
	     const vector_2d& __ctrl_pt2,
	     const vector_2d& __end_pt) noexcept
    : _M_control_pt1{__ctrl_pt1}, _M_control_pt2{__ctrl_pt2},
      _M_end_pt{__end_pt}
    { }

    // modifiers:

    void
    control_point_1(const vector_2d& __ctrl_pt1) noexcept
    { this->_M_control_pt1 = __ctrl_pt1; }

    void
    control_point_2(const vector_2d& __ctrl_pt2) noexcept
    { this->_M_control_pt2 = __ctrl_pt2; }

    void
    end_point(const vector_2d& __end_pt) noexcept
    { this->_M_end_pt = __end_pt; }

    // observers:

    vector_2d
    control_point_1() const noexcept
    { return this->_M_control_pt1; }

    vector_2d
    control_point_2() const noexcept
    { return this->_M_control_pt2; }

    vector_2d
    end_point() const noexcept
    { return this->_M_end_pt; }

    virtual path_data_type
    type() const noexcept override
    { return path_data_type::curve_to; }

  private:

    vector_2d _M_control_pt1;

    vector_2d _M_control_pt2;

    vector_2d _M_end_pt;
  };

  class path_data_item::line_to
  : public path_data_item::path_data
  {
  public:

    // construct/copy/move/destroy:

    line_to() noexcept = default;

    line_to(const line_to&) noexcept = default;

    path_data_item::line_to&
    operator=(const line_to&) noexcept = default;

    line_to(line_to&&) noexcept = default;

    path_data_item::line_to&
    operator=(line_to&&) noexcept = default;

    explicit
    line_to(const vector_2d& __pt) noexcept
    : _M_point{__pt}
    { }

    // modifiers:

    void
    to(const vector_2d& __pt) noexcept
    { this->_M_point = __pt; }

    // observers:

    vector_2d
    to() const noexcept
    { return this->_M_point; }

    virtual path_data_type
    type() const noexcept override
    { return path_data_type::line_to; }

  private:

    vector_2d _M_point;
  };

  /**
   *
   */
  class path_data_item::move_to
  : public path_data_item::path_data
  {
  public:

    // construct/copy/move/destroy:

    move_to() noexcept = default;

    move_to(const move_to&) noexcept = default;

    path_data_item::move_to&
    operator=(const move_to&) noexcept = default;

    move_to(move_to&&) noexcept = default;

    path_data_item::move_to&
    operator=(move_to&&) noexcept = default;

    explicit
    move_to(const vector_2d& __pt) noexcept
    : _M_point{__pt}
    { }

    // modifiers:

    void
    to(const vector_2d& pt) noexcept
    { this->_M_point = __pt; }

    // observers:

    vector_2d
    to() const noexcept
    { return this->_M_point; }

    virtual path_data_type
    type() const noexcept override
    { return path_data_type::move_to; }

  private:

    vector_2d _M_point;
  };

  /**
   *
   */
  class path_data_item::new_sub_path
  : public path_data_item::path_data
  {
  public:

    // construct/copy/move/destroy:

    new_sub_path() noexcept = default;

    new_sub_path(const new_sub_path&) noexcept = default;

    path_data_item::new_sub_path&
    operator=(const new_sub_path&) noexcept = default;

    new_sub_path(new_sub_path&&) noexcept = default;

    path_data_item::new_sub_path&
    operator=(new_sub_path&&) noexcept = default;

    // observers:

    virtual path_data_type
    type() const noexcept override
    { return path_data_type::new_sub_path; }
  };

  /**
   *
   */
  class path_data_item::rel_curve_to
  : public path_data_item::path_data
  {
  public:

    // construct/copy/move/destroy:

    rel_curve_to() noexcept = default;

    rel_curve_to(const rel_curve_to&) noexcept = default;

    path_data_item::rel_curve_to&
    operator=(const rel_curve_to&) noexcept = default;

    rel_curve_to(rel_curve_to&&) noexcept = default;

    path_data_item::rel_curve_to&
    operator=(rel_curve_to&&) noexcept = default;

    rel_curve_to(const vector_2d& __ctrl_pt1,
		 const vector_2d& __ctrl_pt2,
		 const vector_2d& __end_pt) noexcept
    : _M_control_pt1{__ctrl_pt1}, _M_control_pt2{__ctrl_pt2},
      _M_end_pt{__end_pt}
    { }

    // modifiers:

    void
    control_point_1(const vector_2d& __ctrl_pt1) noexcept
    { this->_M_control_pt1 = __ctrl_pt1; }

    void
    control_point_2(const vector_2d& value) noexcept
    { this->_M_control_pt2 = __ctrl_pt2 }

    void
    end_point(const vector_2d& value) noexcept
    { this->_M_end_pt = __end_pt; }

    // 10.3.17.4, observers:
    vector_2d
    control_point_1() const noexcept
    { return this->_M_control_pt1; }

    vector_2d
    control_point_2() const noexcept
    { return this->_M_control_pt2; }

    vector_2d
    end_point() const noexcept
    { return this->_M_end_pt; }

    virtual path_data_type
    type() const noexcept override
    { return path_data_type::rel_curve_to; }

  private:

    vector_2d _M_control_pt1;

    vector_2d _M_control_pt2;

    vector_2d _M_end_pt;
  };

  /**
   *
   */
  class path_data_item::rel_line_to
  : public path_data_item::path_data
  {

  public:

    // construct/copy/move/destroy:

    rel_line_to() noexcept = default;

    rel_line_to(const line_to&) noexcept = default;

    path_data_item::rel_line_to&
    operator=(const line_to&) noexcept = default;

    rel_line_to(line_to&&) noexcept = default;

    path_data_item::rel_line_to&
    operator=(line_to&&) noexcept = default;

    explicit
    rel_line_to(const vector_2d& __pt) noexcept
    : _M_point{__pt}
    { }

    // modifiers:

    void
    to(const vector_2d& pt) noexcept;
    { this->_M_point = __pt }

    // observers:

    vector_2d
    to() const noexcept
    { return this->_M_point; }

    virtual path_data_type
    type() const noexcept override
    { return path_data_type::rel_line_to; }

  private:

    vector_2d _M_point;
  };

  /**
   *
   */
  class path_data_item::rel_move_to
  : public path_data_item::path_data
  {
  public:

    // construct/copy/move/destroy:

    rel_move_to() noexcept = default;

    rel_move_to(const rel_move_to&) noexcept = default;

    path_data_item::rel_move_to&
    operator=(const rel_move_to&) noexcept = default;

    rel_move_to(rel_move_to&&) noexcept = default;

    path_data_item::rel_move_to&
    operator=(rel_move_to&&) noexcept = default;

    explicit
    rel_move_to(const vector_2d& pt) noexcept
    : _M_point{__pt}
    { }

    // modifiers:

    void
    to(const vector_2d& __pt) noexcept
    { this->_M_point = __pt; }

    // observers:

    vector_2d
    to() const noexcept
    { return this->_M_point; }

    virtual path_data_type
    type() const noexcept override
    { return path_data_type::rel_move_to; }

  private:

    vector_2d _M_point;
  };

  /**
   *
   */
  template<>
    path_data_item::arc
    path_data_item::get() const
    {
      std::error_code __ec;
      auto __ret = this->get(__ec);
      if (__ec)
	throw std::someexcept("path_data_item::get: ");
      return __ret;
    }

  template<>
    path_data_item::arc
    path_data_item::get(std::error_code& __ec) const noexcept
    {
      ;
    }

  template<>
    path_data_item::arc_negative
    path_data_item::get() const
    {
      std::error_code __ec;
      auto __ret = this->get(__ec);
      if (__ec)
	throw std::someexcept("path_data_item::get: ");
      return __ret;
    }

  template<>
    path_data_item::arc_negative
    path_data_item::get(std::error_code& __ec) const noexcept
    {
      ;
    }

  template<>
    inline path_data_item::change_matrix
    path_data_item::get() const
    {
      std::error_code __ec;
      auto __ret = this->get(__ec);
      if (__ec)
	throw std::someexcept("path_data_item::get: ");
      return __ret;
    }

  template<>
    path_data_item::change_matrix
    path_data_item::get(std::error_code& __ec) const noexcept
    {
      ;
    }

  template<>
    path_data_item::change_origin
    path_data_item::get() const
    {
      std::error_code __ec;
      auto __ret = this->get(__ec);
      if (__ec)
	throw std::someexcept("path_data_item::get: ");
      return __ret;
    }

  template<>
    path_data_item::change_origin
    path_data_item::get(std::error_code& __ec) const noexcept
    {
      ;
    }

  template<>
    path_data_item::close_path
    path_data_item::get() const
    {
      std::error_code __ec;
      auto __ret = this->get(__ec);
      if (__ec)
	throw std::someexcept("path_data_item::get: ");
      return __ret;
    }

  template<>
    path_data_item::close_path
    path_data_item::get(std::error_code& __ec) const noexcept
    {
      ;
    }

  template<>
    path_data_item::curve_to
    path_data_item::get() const
    {
      std::error_code __ec;
      auto __ret = this->get(__ec);
      if (__ec)
	throw std::someexcept("path_data_item::get: ");
      return __ret;
    }

  template<>
    path_data_item::curve_to
    path_data_item::get(std::error_code& __ec) const noexcept
    {
      ;
    }

  template<>
    path_data_item::rel_curve_to
    path_data_item::get() const
    {
      std::error_code __ec;
      auto __ret = this->get(__ec);
      if (__ec)
	throw std::someexcept("path_data_item::get: ");
      return __ret;
    }

  template<>
    path_data_item::rel_curve_to
    path_data_item::get(std::error_code& __ec) const noexcept
    {
      ;
    }

  template<>
    path_data_item::new_sub_path
    path_data_item::get() const
    {
      std::error_code __ec;
      auto __ret = this->get(__ec);
      if (__ec)
	throw std::someexcept("path_data_item::get: ");
      return __ret;
    }

  template<>
    path_data_item::new_sub_path
    path_data_item::get(std::error_code& __ec) const noexcept
    {
      ;
    }

  template<>
    path_data_item::line_to
    path_data_item::get() const
    {
      std::error_code __ec;
      auto __ret = this->get(__ec);
      if (__ec)
	throw std::someexcept("path_data_item::get: ");
      return __ret;
    }

  template<>
    path_data_item::line_to
    path_data_item::get(std::error_code& __ec) const noexcept
    {
      ;
    }

  template<>
    path_data_item::move_to
    path_data_item::get() const
    {
      std::error_code __ec;
      auto __ret = this->get(__ec);
      if (__ec)
	throw std::someexcept("path_data_item::get: ");
      return __ret;
    }

  template<>
    path_data_item::move_to
    path_data_item::get(std::error_code& __ec) const noexcept
    {
      ;
    }

  template<>
    path_data_item::rel_line_to
    path_data_item::get() const
    {
      std::error_code __ec;
      auto __ret = this->get(__ec);
      if (__ec)
	throw std::someexcept("path_data_item::get: ");
      return __ret;
    }

  template<>
    path_data_item::rel_line_to
    path_data_item::get(std::error_code& __ec) const noexcept
    {
      ;
    }

  template<>
    path_data_item::rel_move_to
    path_data_item::get() const
    {
      std::error_code __ec;
      auto __ret = this->get(__ec);
      if (__ec)
	throw std::someexcept("path_data_item::get: ");
      return __ret;
    }

  template<>
    path_data_item::rel_move_to
    path_data_item::get(std::error_code& __ec) const noexcept
    {
      ;
    }

  /**
   *
   */
  class path
  {

  public:

    // construct/copy/destroy:

    path() = delete;

    explicit
    path(const path_factory& pb);

    path(const path_factory& pb,
	 std::error_code& __ec) noexcept;

    explicit
    path(const std::vector<path_data_item>& p);

    path(const std::vector<path_data_item>& p,
	 std::error_code& __ec) noexcept;

    path(const path&) noexcept;

    path&
    operator=(const path&) noexcept;

    path(path&&) noexcept;

    path&
    operator=(path&&) noexcept;
  };

  class path_factory
  {
  public: // missing from draft.

    // construct/copy/destroy:

    path_factory() noexcept;

    path_factory(const path_factory&);

    path_factory&
    operator=(const path_factory&);

    path_factory(path_factory&&) noexcept;

    path_factory&
    operator=(path_factory&&) noexcept;

    // modifiers:

    void
    append(const path_factory& p);

    void
    append(const path_factory& p,
	   std::error_code& __ec) noexcept;

    void
    append(const std::vector<path_data_item>& p);

    void
    append(const std::vector<path_data_item>& p,
	   std::error_code& __ec) noexcept;

    void
    new_sub_path();

    void
    new_sub_path(std::error_code& __ec) noexcept;

    void
    close_path();

    void
    close_path(std::error_code& __ec) noexcept;

    void
    arc(const vector_2d& center,
	double radius,
	double angle1,
	double angle2);

    void
    arc(const vector_2d& center,
	double radius,
	double angle1,
	double angle2,
	std::error_code& __ec) noexcept;

    void
    arc_negative(const vector_2d& center,
		 double radius,
		 double angle1,
		 double angle2);

    void
    arc_negative(const vector_2d& center,
		 double radius,
		 double angle1,
		 double angle2,
		 std::error_code& __ec) noexcept;

    void
    curve_to(const vector_2d& pt0,
	     const vector_2d& pt1,
	     const vector_2d& pt2);

    void
    curve_to(const vector_2d& pt0,
	     const vector_2d& pt1,
	     const vector_2d& pt2,
	     std::error_code& __ec) noexcept;

    void
    line_to(const vector_2d& pt);

    void
    line_to(const vector_2d& pt,
	    std::error_code& __ec) noexcept;

    void
    move_to(const vector_2d& pt);

    void
    move_to(const vector_2d& pt,
	    std::error_code& __ec) noexcept;

    void
    rectangle(const experimental::io2d::rectangle& r);

    void
    rectangle(const experimental::io2d::rectangle& r,
	      std::error_code& __ec) noexcept;

    void
    rel_curve_to(const vector_2d& dpt0,
		 const vector_2d& dpt1,
		 const vector_2d& dpt2);

    void
    rel_curve_to(const vector_2d& dpt0,
		 const vector_2d& dpt1,
		 const vector_2d& dpt2,
		 std::error_code& __ec) noexcept;

    void
    rel_line_to(const vector_2d& dpt);

    void
    rel_line_to(const vector_2d& dpt,
		std::error_code& __ec) noexcept;

    void
    rel_move_to(const vector_2d& dpt);

    void
    rel_move_to(const vector_2d& dpt,
		std::error_code& __ec) noexcept;

    void
    transform_matrix(const matrix_2d& m);

    void
    transform_matrix(const matrix_2d& m,
		     std::error_code& __ec) noexcept;

    void
    origin(const vector_2d& pt);

    void
    origin(const vector_2d& pt,
	   std::error_code& __ec) noexcept;

    void
    clear() noexcept;

    // observers:

    experimental::io2d::rectangle
    path_extents() const
    { return this->; }

    experimental::io2d::rectangle
    path_extents(std::error_code& __ec) const noexcept
    { return this->; }

    bool
    has_current_point() const noexcept
    { return this->; }

    vector_2d
    current_point() const
    { return this->; }

    vector_2d
    current_point(std::error_code& __ec) const noexcept
    { return this->; }

    matrix_2d
    transform_matrix() const noexcept
    { return this->; }

    vector_2d
    origin() const noexcept
    { return this->; }

    std::vector<path_data_item>
    data() const;
    {
      std::error_code __ec;
      auto _ret = this->data(__ec);
      if (__ec)
	throw std::someexcept();
      return __ret;
    }

    std::vector<path_data_item>
    data(std::error_code& __ec) const noexcept
    {
      // TODO check something?
      __ec.clear();
      return this->_M_data;
    }

    path_data_item
    data_item(unsigned int index) const
    {
      std::error_code __ec;
      auto _ret = this->data_item(__index, __ec);
      if (__ec)
	throw std::someexcept();
      return __ret;
    }

    path_data_item
    data_item(unsigned int __index,
	      std::error_code& __ec) const noexcept
    {
      __ec.clear();
      if (__index >= this->_M_data.size())
	__ec = 666; // FIXME
      return this->_M_data[__index];
    }

    const std::vector<path_data_item>&
    data_ref() const noexcept
    { return this->_M_data; }

  private:

    std::vector<path_data_item> _M_data;

    bool _M_has_current_point;

    vector_2d _M_current_point;

    vector_2d _M_last_move_to_point;

    matrix_2d _M_transform_matrix;

    vector_2d _M_origin;
  };

  /**
   *
   */
  enum class font_slant
  {
    normal,
    italic,
    oblique
  };

  /**
   *
   */
  enum class font_weight
  {
    normal,
    bold
  };

  /**
   *
   */
  enum class subpixel_order
  {
    default_subpixel_order,
    horizontal_rgb,
    horizontal_bgr,
    vertical_rgb,
    vertical_bgr
  };

  /**
   *
   */
  class font_options
  {
  public:

    // construct/copy/destroy:

    font_options() noexcept;

    font_options(const font_options& other) noexcept;

    font_options&
    operator=(const font_options& other) noexcept;

    font_options(font_options&& other) noexcept;

    font_options&
    operator=(font_options&& other) noexcept;

    font_options(std::experimental::io2d::antialias a,
		 std::experimental::io2d::subpixel_order so) noexcept;

    // modifiers:

    void
    antialias(std::experimental::io2d::antialias value) noexcept;

    void
    subpixel_order(std::experimental::io2d::subpixel_order value) noexcept;

    // observers:

    std::experimental::io2d::antialias
    antialias() const noexcept;

    std::experimental::io2d::subpixel_order
    subpixel_order() const noexcept;

  private:

    std::experimental::io2d::antialias _M_antialias;

    std::experimental::io2d::subpixel_order _M_subpixel_order;
};

  /**
   *
   */
  class font_face
  {
  public:

    typedef implementation-defined native_handle_type;

    native_handle_type
    native_handle() const noexcept;

    // construct/copy/destroy:

    font_face() = delete;

    font_face(const font_face&) noexcept;

    font_face&
    operator=(const font_face&) noexcept;

    font_face(font_face&& other) noexcept;

    font_face&
    operator=(font_face&& other) noexcept;

    virtual ~font_face();
  };

  /**
   *
   */
  class simple_font_face
  : public font_face
  {
  public:

    typedef implementation-defined native_handle_type; // exposition only

    native_handle_type
    native_handle() const noexcept; // exposition only

    // construct/copy/destroy:

    simple_font_face() = delete;

    simple_font_face(const simple_font_face&) noexcept;

    simple_font_face&
    operator=(const simple_font_face&) noexcept;

    simple_font_face(simple_font_face&& other) noexcept;

    simple_font_face&
    operator=(simple_font_face&& other) noexcept;

    simple_font_face(const string& typeface,
		     std::experimental::io2d::font_slant fs,
		     std::experimental::io2d::font_weight fw);

    simple_font_face(const string& typeface,
		     std::experimental::io2d::font_slant fs,
		     std::experimental::io2d::font_weight fw,
		     std::error_code& __ec) noexcept;

    // observers:

    string
    typeface() const;

    void
    typeface(string& str,
	     std::error_code& __ec) const noexcept;

    std::experimental::io2d::font_slant
    font_slant() const noexcept;

    std::experimental::io2d::font_weight
    font_weight() const noexcept;

  private:

    string _Typeface;

    std::experimental::io2d::font_slant _M_font_slant;

    std::experimental::io2d::font_weight _M_font_weight;
  };

  /**
   *
   */
  class font_extents
  {
  public:

    // construct/copy/move/destroy:

    font_extents() noexcept;

    font_extents(const font_extents& other) noexcept;

    font_extents&
    operator=(const font_extents& other) noexcept;

    font_extents(font_extents&& other) noexcept;

    font_extents&
    operator=(font_extents&& other) noexcept;

    font_extents(double ascent, double descent, double height) noexcept;

    // modifiers:

    void
    ascent(double value) noexcept;

    void
    descent(double value) noexcept;

    void
    height(double value) noexcept;

    // observers:

    double
    ascent() const noexcept;

    double
    descent() const noexcept;

    double
    height() const noexcept;

  private:

    double _M_asc;

    double _M_desc;

    double _M_height;
  };

  /**
   *
   */
  class text_extents
  {
  public:

    // construct/copy/move/destroy:

    text_extents() noexcept;

    text_extents(const text_extents& other) noexcept;

    text_extents&
    operator=(const text_extents& other) noexcept;

    text_extents(font_extents&& other) noexcept;

    text_extents&
    operator=(font_extents&& other) noexcept;

    text_extents(double xBearing,
		 double yBearing,
		 double width,
		 double height,
		 double xAdvance,
		 double yAdvance) noexcept;

    // modifiers:

    void
    x_bearing(double value) noexcept;

    void
    y_bearing(double value) noexcept;

    void
    width(double value) noexcept;

    void
    height(double value) noexcept;

    void
    x_advance(double value) noexcept;

    void
    y_advance(double value) noexcept;

    // observers:

    double
    x_bearing() const noexcept;

    double
    y_bearing() const noexcept;

    double
    width() const noexcept;

    double
    height() const noexcept;

    double
    x_advance() const noexcept;

    double
    y_advance() const noexcept;

  private:

    double _M_x_bear;

    double _M_y_bear;

    double _M_width;

    double _M_height;

    double _M_x_adv;

    double _M_y_adv;
  };

  /**
   *
   */
  enum class extend
  {
    none,
    repeat,
    reflect,
    pad
  };

  /**
   *
   */
  enum class filter
  {
    fast,
    good,
    best,
    nearest,
    bilinear
  };

  /**
   *
   */
  enum class brush_type
  {
    solid_color,
    surface,
    linear,
    radial,
    mesh
  };

  /**
   *
   */
  class brush
  {
  public:

    // construct/copy/move/destroy:

    brush() = delete;

    brush(const brush&) noexcept = default;

    brush&
    operator=(const brush&) noexcept = default;

    brush(brush&&) noexcept = default;

    brush&
    operator=(brush&&) noexcept = default;

    brush(const solid_color_brush_factory& __fact);

    brush(const solid_color_brush_factory& __fact,
	  std::error_code& __ec) noexcept;

    brush(const linear_brush_factory& __fact);

    brush(const linear_brush_factory& __fact,
	  std::error_code& __ec) noexcept;

    brush(const radial_brush_factory& __fact);

    brush(const radial_brush_factory& __fact,
	  std::error_code& __ec) noexcept;

    brush(const surface_brush_factory& __fact); // FIXME: Added const??

    brush(const surface_brush_factory& __fact, // FIXME: Added const??
	  std::error_code& __ec) noexcept;

    // modifiers:

    void
    extend(experimental::io2d::extend __ext) noexcept
    { this->_M_extend = __ext; }

    void
    filter(experimental::io2d::filter __filt) noexcept
    { this->_M_filter = __filt; }

    void
    matrix(const matrix_2d& __mat) noexcept
    { this->_M_matrix = __mat; }

    // observers:

    experimental::io2d::extend
    extend() const noexcept
    { return this->_M_extend; }

    experimental::io2d::filter
    filter() const noexcept
    { return this->_M_filter; }

    matrix_2d
    matrix() const noexcept
    { return this->_M_matrix; }

    brush_type
    type() const noexcept
    { return this->_M_brush_type; }

  private:

    experimental::io2d::extend _M_extend;

    experimental::io2d::filter _M_filter;

    matrix_2d _M_matrix;

    brush_type _M_brush_type;
  };

  /**
   *
   */
  class solid_color_brush_factory
  {
  public:

    // construct/copy/move/destroy:

    solid_color_brush_factory() noexcept = default;

    solid_color_brush_factory(const solid_color_brush_factory&) noexcept = default;

    solid_color_brush_factory&
    operator=(const solid_color_brush_factory&) noexcept = default;

    solid_color_brush_factory(solid_color_brush_factory&&) noexcept = default;

    solid_color_brush_factory&
    operator=(solid_color_brush_factory&&) noexcept = default;

    solid_color_brush_factory(const rgba_color& __color) noexcept
    : _M_color{__color}
    { }

    // modifiers:

    void
    color(const rgba_color& __value) noexcept
    { this->_M_color = __value; }

    // observers:

    rgba_color
    color() const noexcept;

  private:

    rgba_color _M_color;
  };

  /**
   *
   */
  class linear_brush_factory
  {
  public:

    // types

    typedef /*implementation-defined*/ std::size_t size_type;

    // construct/copy/move/destroy:

    linear_brush_factory() noexcept = default;

    linear_brush_factory(const linear_brush_factory&) = default;

    linear_brush_factory&
    operator=(const linear_brush_factory&) = default;

    linear_brush_factory(linear_brush_factory&&) noexcept = default;

    linear_brush_factory&
    operator=(linear_brush_factory&&) noexcept = default;

    linear_brush_factory(const vector_2d& __begin,
			 const vector_2d& __end) noexcept
    : _M_begin_point{__begin}, _M_end_point{__end},
      _M_color_stops{} // FIXME? std default colorstops?
    { }

    // modifiers:

    void
    add_color_stop(double offset,
		   const rgba_color& __color)
    {
      std::error_code __ec;
      this->add_color_stop(__offset, __color, __ec);
      if (__ec)
	throw std::someexception();
    }

    void
    add_color_stop(double __offset,
		   const rgba_color& __color,
		   std::error_code& __ec) noexcept
    {
      //  TODO: Check offet I think.
      __ec.clear();
      this->_M_color_stops.emplace_back(__offset, __color);
    }

    void
    color_stop(size_type __index,
	       double __offset,
	       const rgba_color& __color)
    {
      std::error_code __ec;
      this->color_stop(__index, __offset, __color, __ec);
      if (__ec)
	throw std::someexception();
    }

    void
    color_stop(size_type __index,
	       double __offset,
	       const rgba_color& __color,
	       std::error_code& __ec) noexcept
    {
      __ec.clear();
      if (__index >= this->_M_color_stops.size())
	__ec = 666; // FIXME
      auto& __stop = this->_M_color_stops[__index];
      std::get<double>(__stop) = __offset;
      std::get<rgba_color>(__stop) = __color;
    }

    void
    begin_point(const vector_2d& __value) noexcept
    { this->_M_begin_point = __value; }

    void
    end_point(const vector_2d& __value) noexcept
    { this->_M_end_point; = __value; }

    // observers:

    size_type
    color_stop_count() const noexcept
    { return this->_M_color_stops.size(); }

    std::tuple<double, rgba_color>
    color_stop(size_type __index) const
    {
      std::error_code __ec;
      auto __ret = this->color_stop(__index, __ec);
      if (__ec)
	throw std::someexception();
      return __ret;
    }

    std::tuple<double, rgba_color>
    color_stop(size_type __index,
	       std::error_code& __ec) const noexcept
    {
      __ec.clear();
      if (__index >= _M_color_stops.size())
	__ec = 666; // FIXME
      return this->_M_color_stops.at(__index);
    }

    vector_2d
    begin_point() const noexcept
    { return this->_M_begin_point; }

    vector_2d
    end_point() const noexcept
    { return this->_M_end_point; }

  private:

    vector_2d _M_begin_point;

    vector_2d _M_end_point;

    std::vector<std::tuple<double, rgba_color>> _M_color_stops;
  };

  /**
   *  TODO: Why not a single radius?  Do we care if one center is outside the other circle?
   */
  class radial_brush_factory
  {
  public:

    // types

    typedef /*implementation-defined*/ std::size_t size_type;

    // construct/copy/move/destroy:

    radial_brush_factory() noexcept = default;

    radial_brush_factory(const radial_brush_factory&) = default;

    radial_brush_factory&
    operator=(const radial_brush_factory&) = default;

    radial_brush_factory(radial_brush_factory&&) noexcept = default;

    radial_brush_factory&
    operator=(radial_brush_factory&&) noexcept = default;

    radial_brush_factory(const vector_2d& __center0, double __radius0,
			 const vector_2d& __center1, double __radius1) noexcept
    : _M_center0{__center0}, _M_radius0{__radius0},
      _M_center1{__center1}, _M_radius1{__radius1},
      _M_color_stops{} // TODO: Default color stops?
    { }

    // modifiers:

    void
    add_color_stop(double __offset,
		   const rgba_color& __color)
    {
      std::error_code __ec;
      this->add_color_stop(__offset, __color, __ec);
      if (__ec)
	throw std::someexception();
    }

    void
    add_color_stop(double __offset,
		   const rgba_color& __color,
		   std::error_code& __ec) noexcept
    {
      __ec.clear();
      //  TODO: Check offet I think.
      this->_M_color_stops.emplace_back(__offset, __color);
    }

    void
    color_stop(size_type index,
	       double offset,
	       const rgba_color& color)
    {
      std::error_code __ec;
      this->color_stop(__index, __offset, __color, __ec);
      if (__ec)
	throw std::someexception();
    }

    void
    color_stop(size_type index,
	       double offset,
	       const rgba_color& color,
	       std::error_code& __ec) noexcept
    {
      __ec.clear();
      if (__index >= this->_M_color_stops.size())
	__ec = 666; // FIXME
      auto& __stop = this->_M_color_stops[__index];
      std::get<double>(__stop) = __offset;
      std::get<rgba_color>(__stop) = __color;
    }

    void
    radial_circles(const vector_2d& center0,
		   double radius0,
		   const vector_2d& center1,
		   double radius1) noexcept
    {
      this->_M_center0 = center0;
      this->_M_radius0 = radius0;
      this->_M_center1 = center1;
      this->_M_radius1 = radius1;
    }

    // observers:

    size_type
    color_stop_count() const noexcept
    { return this->_M_color_stops.size(); }

    std::tuple<double, rgba_color>
    color_stop(size_type index) const
    {
      std::error_code __ec;
      auto __ret = this->color_stop(__index, __ec);
      if (__ec)
	throw std::someexception();
      return __ret;
    }

    std::tuple<double, __rgba_color>
    color_stop(size_type __index,
	       std::error_code& __ec) const noexcept
    {
      __ec.clear();
      if (__index >= _M_color_stops.size())
	__ec = 666; // FIXME
      return this->_M_color_stops.at(__index);
    }

    std::tuple<vector_2d, double, vector_2d, double>
    radial_circles() const noexcept;

  private:

    vector_2d _M_center0;

    double _M_radius0;

    vector_2d _M_center1;

    double _M_radius1;

    std::vector<std::tuple<double, rgba_color>> _M_color_stops;
  };

  class image_surface;

  /**
   *
   */
  class surface_brush_factory
  {
  public:

    // construct/copy/move/destroy:

    surface_brush_factory() noexcept;

    surface_brush_factory(const surface_brush_factory&) = delete;

    surface_brush_factory&
    operator=(const surface_brush_factory&) = delete;

    surface_brush_factory(surface_brush_factory&& other) noexcept = default;

    surface_brush_factory&
    operator=(surface_brush_factory&&) noexcept = default;

    surface_brush_factory(experimental::io2d::surface& __surf);

    surface_brush_factory(experimental::io2d::surface& __surf,
			  std::error_code& __ec) noexcept;

    // modifiers:

    image_surface
    surface(experimental::io2d::surface& s);

    void
    surface(experimental::io2d::surface& s,
	    image_surface& oldSurface,
	    std::error_code& __ec) noexcept;

    void
    surface(experimental::io2d::surface& s,
	    std::error_code& __ec) noexcept;

    // observers:

    bool
    has_surface() const noexcept;

    const image_surface&
    surface() const;

  private:

    std::unique_ptr<image_surface> _M_surface;
  };

  /**
   *
   */
  enum class antialias
  {
    default_antialias,
    none,
    gray,
    subpixel,
    fast,
    good,
    best
  };

  /**
   *
   */
  enum class content
  {
    color,
    alpha,
    color_alpha
  };

  /**
   *
   */
  enum class fill_rule
  {
    winding,
    even_odd
  };

  /**
   *
   */
  enum class line_cap
  {
    butt,
    round,
    square
  };

  /**
   *
   */
  enum class line_join
  {
    miter,
    round,
    bevel
  };

  /**
   *
   */
  enum class compositing_operator
  {
    // basic
    over,
    clear,
    source,
    in,
    out,
    atop,
    dest,
    dest_over,
    dest_in,
    dest_out,
    dest_atop,
    xor_op,
    add,
    saturate,
    // blend
    multiply,
    screen,
    overlay,
    darken,
    lighten,
    color_dodge,
    color_burn,
    hard_light,
    soft_light,
    difference,
    exclusion,
    // hsl
    hsl_hue,
    hsl_saturation,
    hsl_color,
    hsl_luminosity
  };

  /**
   *
   */
  enum class format
  {
    invalid,
    argb32,
    rgb24,
    a8,
    rgb16_565,
    rgb30
  };

  /**
   *
   */
  enum class scaling
  {
    letterbox,
    uniform,
    fill_uniform,
    fill_exact,
    none
  };

  /**
   *
   */
  class device
  {
  public:

    typedef implementation-defined native_handle_type;

    // exposition only

    native_handle_type native_handle() const noexcept;

    // exposition only

    device() = delete;

    device(const device&) = delete;

    device&
    operator=(const device&) = delete;

    device(device&& other);

    device&
    operator=(device&& other);

    // modifiers:

    void
    flush() noexcept;

    void
    lock();

    void
    lock(std::error_code& __ec) noexcept;

    void
    unlock();

    void
    unlock(std::error_code& __ec) noexcept;
  };

  /**
   *
   */
  class surface
  {
  public:

    // constructors, assignment operators, destructors:

    surface() = delete;

    surface(const surface&) = delete;

    surface& operator=(const surface&) = delete;

    surface(surface&& other) noexcept;

    surface& operator=(surface&& other) noexcept;

    virtual ~surface();

    // state modifiers:

    virtual void
    finish() noexcept;

    void
    flush();

    void
    flush(std::error_code& __ec) noexcept;

    std::shared_ptr<experimental::io2d::device>
    device();

    std::shared_ptr<experimental::io2d::device>
    device(std::error_code& __ec) noexcept;

    void mark_dirty();

    void mark_dirty(std::error_code& __ec) noexcept;

    void
    mark_dirty(const rectangle& rect);

    void
    mark_dirty(const rectangle& rect,
	       std::error_code& __ec) noexcept;

    void
    map(const std::function<void(mapped_surface&)>& action);

    void
    map(const std::function<void(mapped_surface&, std::error_code&)>& action,
	std::error_code& __ec);

    void
    map(const std::function<void(mapped_surface&)>& action,
	const rectangle& extents);

    void
    map(const std::function<void(mapped_surface&, std::error_code&)>& action,
	const rectangle& extents,
	std::error_code& __ec);

    virtual void
    save();

    virtual void
    save(std::error_code& __ec) noexcept;

    virtual void
    restore();

    virtual void
    restore(std::error_code& __ec) noexcept;

    void
    brush(experimental::nullopt_t) noexcept;

    void
    brush(const experimental::io2d::brush& source);

    void
    brush(const experimental::io2d::brush& source,
	  std::error_code& __ec) noexcept;

    void
    antialias(experimental::io2d::antialias a) noexcept;

    void
    dashes(experimental::nullopt_t) noexcept;

    void
    dashes(const experimental::io2d::dashes& d);

    void
    dashes(const experimental::io2d::dashes& d,
	   std::error_code& __ec) noexcept;

    void
    fill_rule(experimental::io2d::fill_rule fr) noexcept;

    void
    line_cap(experimental::io2d::line_cap lc) noexcept;

    void
    line_join(experimental::io2d::line_join lj) noexcept;

    void
    line_width(double width) noexcept;

    void
    miter_limit(double limit) noexcept;

    void
    compositing_operator(experimental::io2d::compositing_operator co) noexcept;

    void
    clip(const experimental::io2d::path& p);

    void
    clip(const experimental::io2d::path& p,
	 std::error_code& __ec) noexcept;

    void
    clip_immediate();

    void
    clip_immediate(std::error_code& __ec) noexcept;

    void
    path(experimental::nullopt_t) noexcept;

    void
    path(const experimental::io2d::path& p);

    void
    path(const experimental::io2d::path& p,
	 std::error_code& __ec) noexcept;

    // immediate path modifiers:

    experimental::io2d::path_factory&
    immediate() noexcept;

    // render modifiers:

    void
    fill();

    void
    fill(std::error_code& __ec) noexcept;

    void
    fill(const rgba_color& c);

    void
    fill(const rgba_color& c,
	 std::error_code& __ec) noexcept;

    void
    fill(const experimental::io2d::brush& b);

    void
    fill(const experimental::io2d::brush& b,
	 std::error_code& __ec) noexcept;

    void
    fill(const surface& s,
	 const vector_2d& o = vector_2d{ },
	 extend e = extend::none,
	 filter f = filter::good);

    void
    fill(const surface& s,
	 std::error_code& __ec,
	 const vector_2d& o = vector_2d{ },
	 extend e = extend::none,
	 filter f = filter::good) noexcept;

    void
    fill(const surface& s,
	 const matrix_2d& m,
	 extend e = extend::none,
	 filter f = filter::good);

    void
    fill(const surface& s,
	 const matrix_2d& m,
	 std::error_code& __ec,
	 extend e = extend::none,
	 filter f = filter::good) noexcept;

    void
    fill_immediate();

    void
    fill_immediate(std::error_code& __ec) noexcept;

    void
    fill_immediate(const rgba_color& c);

    void
    fill_immediate(const rgba_color& c,
		   std::error_code& __ec) noexcept;

    void
    fill_immediate(const experimental::io2d::brush& b);

    void
    fill_immediate(const experimental::io2d::brush& b,
		   std::error_code& __ec) noexcept;

    void
    fill_immediate(const surface& s,
		   const vector_2d& o = vector_2d{ },
		   extend e = extend::none,
		   filter f = filter::good);

    void
    fill_immediate(const surface& s,
		   std::error_code& __ec,
		   const vector_2d& o = vector_2d{ },
		   extend e = extend::none,
		   filter f = filter::good) noexcept;

    void
    fill_immediate(const surface& s,
		   const matrix_2d& m,
		   extend e = extend::none,
		   filter f = filter::good);

    void
    fill_immediate(const surface& s,
		   const matrix_2d& m,
		   std::error_code& __ec,
		   extend e = extend::none,
		   filter f = filter::good) noexcept;

    void
    paint();

    void
    paint(std::error_code& __ec) noexcept;

    void
    paint(const rgba_color& c);

    void
    paint(const rgba_color& c,
	  std::error_code& __ec) noexcept;

    void
    paint(const experimental::io2d::brush& b);

    void
    paint(const experimental::io2d::brush& b,
	  std::error_code& __ec) noexcept;

    void
    paint(const surface& s,
	  const vector_2d& o = vector_2d{ },
	  extend e = extend::none,
	  filter f = filter::good);

    void
    paint(const surface& s,
	  std::error_code& __ec,
	  const vector_2d& o = vector_2d{ },
	  extend e = extend::none,
	  filter f = filter::good) noexcept;

    void
    paint(const surface& s,
	  const matrix_2d& m,
	  extend e = extend::none,
	  filter f = filter::good);

    void
    paint(const surface& s,
	  const matrix_2d& m,
	  std::error_code& __ec,
	  extend e = extend::none,
	  filter f = filter::good) noexcept;

    void
    paint(double alpha);

    void
    paint(double alpha,
	  std::error_code& __ec) noexcept;

    void
    paint(const rgba_color& c,
	  double alpha);

    void
    paint(const rgba_color& c,
	  double alpha,
	  std::error_code& __ec) noexcept;

    void
    paint(const experimental::io2d::brush& b,
	  double alpha);

    void
    paint(const experimental::io2d::brush& b,
	  double alpha,
	  std::error_code& __ec) noexcept;

    void
    paint(const surface& s,
	  double alpha,
	  const vector_2d& o = vector_2d{ },
	  extend e = extend::none,
	  filter f = filter::good);

    void
    paint(const surface& s,
	  double alpha,
	  std::error_code& __ec,
	  const vector_2d& o = vector_2d{ },
	  extend e = extend::none,
	  filter f = filter::good) noexcept;

    void
    paint(const surface& s,
	  double alpha,
	  const matrix_2d& m,
	  extend e = extend::none,
	  filter f = filter::good);

    void
    paint(const surface& s,
	  double alpha,
	  const matrix_2d& m,
	  std::error_code& __ec,
	  extend e = extend::none,
	  filter f = filter::good) noexcept;

    void
    stroke();

    void
    stroke(std::error_code& __ec) noexcept;

    void
    stroke(const rgba_color& c);

    void
    stroke(const rgba_color& c,
	   std::error_code& __ec) noexcept;

    void
    stroke(const experimental::io2d::brush& b);

    void
    stroke(const experimental::io2d::brush& b,
	   std::error_code& __ec) noexcept;

    void
    stroke(const surface& s,
	   const vector_2d& o = vector_2d{ },
	   extend e = extend::none,
	   filter f = filter::good);

    void
    stroke(const surface& s, std::error_code& __ec,
	   const vector_2d& o = vector_2d{ },
	   extend e = extend::none,
	   filter f = filter::good) noexcept;

    void
    stroke(const surface& s,
	   const matrix_2d& m,
	   extend e = extend::none,
	   filter f = filter::good);

    void
    stroke(const surface& s,
	   const matrix_2d& m,
	   std::error_code& __ec,
	   extend e = extend::none,
	   filter f = filter::good) noexcept;

    void
    stroke_immediate();

    void
    stroke_immediate(std::error_code& __ec) noexcept;

    void
    stroke_immediate(const rgba_color& c);

    void
    stroke_immediate(const rgba_color& c,
		     std::error_code& __ec) noexcept;

    void
    stroke_immediate(const experimental::io2d::brush& b);

    void
    stroke_immediate(const experimental::io2d::brush& b,
		     std::error_code& __ec) noexcept;

    void
    stroke_immediate(const surface& s,
		     const vector_2d& o = vector_2d{ },
		     extend e = extend::none,
		     filter f = filter::good);

    void
    stroke_immediate(const surface& s,
		     std::error_code& __ec,
		     const vector_2d& o = vector_2d{ },
		     extend e = extend::none,
		     filter f = filter::good) noexcept;

    void
    stroke_immediate(const surface& s,
		     const matrix_2d& m,
		     extend e = extend::none,
		     filter f = filter::good);

    void
    stroke_immediate(const surface& s,
		     const matrix_2d& m,
		     std::error_code& __ec,
		     extend e = extend::none,
		     filter f = filter::good) noexcept;

    // mask render modifiers:

    void
    mask(const experimental::io2d::brush& mb);

    void
    mask(const experimental::io2d::brush& mb,
	 std::error_code& __ec) noexcept;

    void
    mask(const experimental::io2d::brush& mb,
	 const rgba_color& c);

    void
    mask(const experimental::io2d::brush& mb,
	 const rgba_color& c,
	 std::error_code& __ec) noexcept;

    void
    mask(const experimental::io2d::brush& mb,
	 const experimental::io2d::brush& b);

    void
    mask(const experimental::io2d::brush& mb,
	 const experimental::io2d::brush& b,
	 std::error_code& __ec) noexcept;

    void
    mask(const experimental::io2d::brush& mb,
	 const surface& s,
	 const vector_2d& o = vector_2d{ },
	 extend e = extend::none,
	 filter f = filter::good);

    void
    mask(const experimental::io2d::brush& mb,
	 const surface& s,
	 std::error_code& __ec,
	 const vector_2d& o = vector_2d{ },
	 extend e = extend::none,
	 filter f = filter::good) noexcept;

    void
    mask(const experimental::io2d::brush& mb,
	 const surface& s,
	 const matrix_2d& m,
	 extend e = extend::none
	 filter f = filter::good);

    void
    mask(const experimental::io2d::brush& mb,
    const surface& s,
	 const matrix_2d& m, std::error_code& __ec,
	 extend e = extend::none,
	 filter f = filter::good) noexcept;

    void
    mask(const surface& ms);

    void
    mask(const surface& ms,
	 std::error_code& __ec) noexcept;

    void
    mask(const surface& ms,
	 const rgba_color& c);

    void
    mask(const surface& ms,
	 const rgba_color& c, std::error_code& __ec) noexcept;

    void
    mask(const surface& ms,
    const experimental::io2d::brush& b);

    void
    mask(const surface& ms,
	 const experimental::io2d::brush& b,
	 std::error_code& __ec) noexcept;

    void
    mask(const surface& ms,
	 const surface& s,
	 const vector_2d& o = vector_2d{ },
	 extend e = extend::none,
	 filter f = filter::good);

    void
    mask(const surface& ms,
	 const surface& s,
	 std::error_code& __ec,
	 const vector_2d& o = vector_2d{ },
	 extend e = extend::none,
	 filter f = filter::good) noexcept;

    void
    mask(const surface& ms,
	 const surface& s,
	 const matrix_2d& m,
	 extend e = extend::none,
	 filter f = filter::good);

    void
    mask(const surface& ms,
	 const surface& s,
	 const matrix_2d& m,
	 std::error_code& __ec,
	 extend e = extend::none,
	 filter f = filter::good) noexcept;

    void
    mask(const surface& ms,
	 const vector_2d& mo);

    void
    mask(const surface& ms,
	 const vector_2d& mo,
	 std::error_code& __ec) noexcept;

    void
    mask(const surface& ms,
	 const vector_2d& mo,
	 const rgba_color& c);

    void
    mask(const surface& ms,
	 const vector_2d& mo,
	 const rgba_color& c,
	 std::error_code& __ec) noexcept;

    void
    mask(const surface& ms,
	 const vector_2d& mo,
	 const experimental::io2d::brush& b);

    void
    mask(const surface& ms,
	 const vector_2d& mo,
	 const experimental::io2d::brush& b,
	 std::error_code& __ec) noexcept;

    void
    mask(const surface& ms,
	 const vector_2d& mo,
	 const surface& s,
	 const vector_2d& o = vector_2d{ },
	 extend e = extend::none,
	 filter f = filter::good);

    void
    mask(const surface& ms,
	 const vector_2d& mo,
	 const surface& s,
	 std::error_code& __ec,
	 const vector_2d& o = vector_2d{ },
	 extend e = extend::none,
	 filter f = filter::good) noexcept;

    void
    mask(const surface& ms,
	 const vector_2d& mo,
	 const surface& s,
	 const matrix_2d& m,
	 extend e = extend::none,
	 filter f = filter::good);

    void
    mask(const surface& ms,
	 const vector_2d& mo,
	 const surface& s,
	 const matrix_2d& m,
	 std::error_code& __ec,
	 extend e = extend::none,
	 filter f = filter::good) noexcept;

    void
    mask_immediate(const experimental::io2d::brush& mb);

    void
    mask_immediate(const experimental::io2d::brush& mb,
		   std::error_code& __ec) noexcept;

    void
    mask_immediate(const experimental::io2d::brush& mb,
		   const rgba_color& c);

    void
    mask_immediate(const experimental::io2d::brush& mb,
		   const rgba_color& c, std::error_code& __ec) noexcept;

    void
    mask_immediate(const experimental::io2d::brush& mb,
		   const experimental::io2d::brush& b);

    void
    mask_immediate(const experimental::io2d::brush& mb,
		   const experimental::io2d::brush& b,
		   std::error_code& __ec) noexcept;

    void
    mask_immediate(const experimental::io2d::brush& mb,
    const surface& s,
		   const vector_2d& o = vector_2d{ },
		   extend e = extend::none,
		   filter f = filter::good);

    void
    mask_immediate(const experimental::io2d::brush& mb,
    const surface& s,
		   std::error_code& __ec,
		   const vector_2d& o = vector_2d{ },
		   extend e = extend::none,
		   filter f = filter::good) noexcept;

    void
    mask_immediate(const experimental::io2d::brush& mb,
    const surface& s,
		   const matrix_2d& m,
		   extend e = extend::none,
		   filter f = filter::good);

    void
    mask_immediate(const experimental::io2d::brush& mb,
    const surface& s,
		   const matrix_2d& m,
		   std::error_code& __ec,
		   extend e = extend::none,
		   filter f = filter::good) noexcept;

    void
    mask_immediate(const surface& ms);

    void
    mask_immediate(const surface& ms,
		   std::error_code& __ec) noexcept;

    void
    mask_immediate(const surface& ms,
		   const rgba_color& c);

    void
    mask_immediate(const surface& ms,
		   const rgba_color& c,
		   std::error_code& __ec) noexcept;

    void
    mask_immediate(const surface& ms,
		   const experimental::io2d::brush& b);

    void
    mask_immediate(const surface& ms,
		   const experimental::io2d::brush& b,
		   std::error_code& __ec) noexcept;

    void
    mask_immediate(const surface& ms,
		   const surface& s,
		   const vector_2d& o = vector_2d{ },
		   extend e = extend::none,
		   filter f = filter::good);

    void
    mask_immediate(const surface& ms,
		   const surface& s,
		   std::error_code& __ec,
		   const vector_2d& o = vector_2d{ },
		   extend e = extend::none,
		   filter f = filter::good) noexcept;

    void
    mask_immediate(const surface& ms,
		   const surface& s,
		   const matrix_2d& m,
		   extend e = extend::none,
		   filter f = filter::good);

    void
    mask_immediate(const surface& ms,
		   const surface& s,
		   const matrix_2d& m,
		   std::error_code& __ec,
		   extend e = extend::none,
		   filter f = filter::good) noexcept;

    void
    mask_immediate(const surface& ms,
		   const vector_2d& mo);

    void
    mask_immediate(const surface& ms,
		   const vector_2d& mo,
		   std::error_code& __ec) noexcept;

    void
    mask_immediate(const surface& ms,
		   const vector_2d& mo,
		   const rgba_color& c);

    void
    mask_immediate(const surface& ms,
		   const vector_2d& mo,
		   const rgba_color& c,
		   std::error_code& __ec) noexcept;

    void
    mask_immediate(const surface& ms,
		   const vector_2d& mo,
		   const experimental::io2d::brush& b);

    void
    mask_immediate(const surface& ms,
		   const vector_2d& mo,
		   const experimental::io2d::brush& b,
		   std::error_code& __ec) noexcept;

    void
    mask_immediate(const surface& ms,
		   const vector_2d& mo,
		   const surface& s,
		   const vector_2d& o = vector_2d{ },
		   extend e = extend::none,
		   filter f = filter::good);

    void
    mask_immediate(const surface& ms,
		   const vector_2d& mo,
		   const surface& s,
		   std::error_code& __ec,
		   const vector_2d& o = vector_2d{ },
		   extend e = extend::none,
		   filter f = filter::good) noexcept;

    void
    mask_immediate(const surface& ms,
		   const vector_2d& mo,
		   const surface& s,
		   const matrix_2d& m,
		   extend e = extend::none,
		   filter f = filter::good);

    void
    mask_immediate(const surface& ms,
		   const vector_2d& mo,
		   const surface& s,
		   const matrix_2d& m, std::error_code& __ec,
		   extend e = extend::none,
		   filter f = filter::good) noexcept;

    // text render modifiers:

    vector_2d
    render_text(const string& utf8,
		const vector_2d& pos);

    vector_2d
    render_text(const string& utf8,
		const vector_2d& pos,
		std::error_code& __ec) noexcept;

    vector_2d
    render_text(const string& utf8,
		const vector_2d& pos,
		const rgba_color& c);

    vector_2d
    render_text(const string& utf8,
		const vector_2d& pos,
		const rgba_color& c,
		std::error_code& __ec) noexcept;

    vector_2d
    render_text(const string& utf8,
		const vector_2d& pos,
		const experimental::io2d::brush& b);

    vector_2d
    render_text(const string& utf8,
		const vector_2d& pos,
		const experimental::io2d::brush& b,
		std::error_code& __ec) noexcept;

    vector_2d
    render_text(const string& utf8,
		const vector_2d& pos,
		const surface& s,
		const vector_2d& o = vector_2d{ },
		extend e = extend::none,
		filter f = filter::good);

    vector_2d
    render_text(const string& utf8,
		const vector_2d& pos,
		const surface& s,
		std::error_code& __ec,
		const vector_2d& o = vector_2d{ },
		extend e = extend::none,
		filter f = filter::good) noexcept;

    vector_2d
    render_text(const string& utf8,
		const vector_2d& pos,
		const surface& s, const matrix_2d& m,
		extend e = extend::none,
		filter f = filter::good);

    vector_2d
    render_text(const string& utf8,
		const vector_2d& pos,
		const surface& s, const matrix_2d& m,
		std::error_code& __ec,
		extend e = extend::none,
		filter f = filter::good) noexcept;

    // transformation modifiers:

    void
    matrix(const matrix_2d& matrix);

    void
    matrix(const matrix_2d& matrix,
	   std::error_code& __ec) noexcept;

    // font modifiers:

    void
    font_face(const string& typeface,
	      font_slant sl, font_weight w);

    void
    font_face(const string& typeface,
	      font_slant sl, font_weight w,
	      std::error_code& __ec) noexcept;

    void
    font_face(const experimental::io2d::font_face& f);

    void
    font_face(const experimental::io2d::font_face& f,
	      std::error_code& __ec) noexcept;

    void
    font_size(double s) noexcept;

    void
    font_matrix(const matrix_2d& m);

    void
    font_matrix(const matrix_2d& m,
		std::error_code& __ec) noexcept;

    void
    font_options(const font_options& fo) noexcept;

    // state observers:

    bool
    is_finished() const noexcept;

    experimental::io2d::content
    content() const noexcept;

    experimental::io2d::brush
    brush() const noexcept;

    experimental::io2d::antialias
    antialias() const noexcept;

    experimental::io2d::dashes
    dashes() const;

    experimental::io2d::dashes
    dashes(std::error_code& __ec) const noexcept;

    experimental::io2d::fill_rule
    fill_rule() const noexcept;

    experimental::io2d::line_cap
    line_cap() const noexcept;

    experimental::io2d::line_join
    line_join() const noexcept;

    double
    line_width() const noexcept;

    double
    miter_limit() const noexcept;

    experimental::io2d::compositing_operator
    compositing_operator() const noexcept;

    rectangle
    clip_extents() const noexcept;

    bool
    in_clip(const vector_2d& pt) const noexcept;

    std::vector<rectangle>
    clip_rectangles() const;

    std::vector<rectangle>
    clip_rectangles(std::error_code& __ec) const noexcept;

    // render observers:

    rectangle
    fill_extents() const noexcept;

    rectangle
    fill_extents_immediate() const;

    rectangle
    fill_extents_immediate(std::error_code& __ec) const noexcept;

    bool
    in_fill(const vector_2d& pt) const noexcept;

    bool
    in_fill_immediate(const vector_2d& pt) const;

    bool
    in_fill_immediate(const vector_2d& pt,
		      std::error_code& __ec) const noexcept;

    rectangle
    stroke_extents() const noexcept;

    rectangle
    stroke_extents_immediate() const;

    rectangle
    stroke_extents_immediate(std::error_code& __ec) const noexcept;

    bool
    in_stroke(const vector_2d& pt) const noexcept;

    bool
    in_stroke_immediate(const vector_2d& pt) const;

    bool
    in_stroke_immediate(const vector_2d& pt,
			std::error_code& __ec) const noexcept;
 
    experimental::io2d::font_extents
    font_extents() const noexcept;

    experimental::io2d::text_extents
    text_extents(const string& utf8) const;

    experimental::io2d::text_extents
    text_extents(const string& utf8,
		 std::error_code& __ec) const noexcept;

    // transformation observers:

    matrix_2d
    matrix() const noexcept;

    vector_2d
    user_to_surface(const vector_2d& pt) const noexcept;

    vector_2d
    user_to_surface_distance(const vector_2d& dpt) const noexcept;

    vector_2d
    surface_to_user(const vector_2d& pt) const noexcept;

    vector_2d
    surface_to_user_distance(const vector_2d& dpt) const noexcept;

    // font observers:

    matrix_2d
    font_matrix() const noexcept;

    experimental::io2d::font_options
    font_options() const noexcept;

    experimental::io2d::font_face
    font_face() const;

    experimental::io2d::font_face
    font_face(std::error_code& __ec) const noexcept;
};

  /**
   *
   */
  class image_surface
  : public surface
  {
  public:

    // construct/copy/move/destroy:

    image_surface() = delete;

    image_surface(const image_surface&) = delete;

    image_surface&
    operator=(const image_surface&) = delete;

    image_surface(image_surface&& other) noexcept = default;

    image_surface&
    operator=(image_surface&& other) noexcept = default;

    image_surface(experimental::io2d::format __fmt,
		  int __width, int __height);

    image_surface(experimental::io2d::format __fmt,
		  int __width, int __height,
		  std::error_code& __ec) noexcept;

    image_surface(std::vector<unsigned char>& __data,
		  experimental::io2d::format __fmt,
		  int __width, int __height);

    image_surface(std::vector<unsigned char>& __data,
		  experimental::io2d::format __fmt,
		  int __width, int __height, std::error_code& __ec) noexcept;

    virtual ~image_surface();

    // modifiers:

    void
    data(const std::vector<unsigned char>& __data);

    void
    data(const std::vector<unsigned char>& __data, std::error_code& __ec) noexcept;

    std::vector<unsigned char>
    data();

    std::vector<unsigned char>
    data(std::error_code& __ec) noexcept;

    // observers:

    experimental::io2d::format
    format() const noexcept;

    int
    width() const noexcept;

    int
    height() const noexcept;

    int
    stride() const noexcept;
  };

 /**
  *
  */
  class display_surface
  : public surface
  {
  public:

    // construct/copy/move/destroy:

    display_surface() = delete;

    display_surface(const display_surface&) = delete;

    display_surface&
    operator=(const display_surface&) = delete;

    display_surface(display_surface&& other) noexcept = default;

    display_surface&
    operator=(display_surface&& other) noexcept = default;

    display_surface(int __pref_width,
		    int __pref_height,
		    experimental::io2d::format __pref_fmt,
		    experimental::io2d::scaling  __scl = experimental::io2d::scaling::letterbox);

    display_surface(int __pref_width,
		    int __pref_height,
		    experimental::io2d::format __pref_fmt,
		    std::error_code& __ec,
		    experimental::io2d::scaling  __scl = experimental::io2d::scaling::letterbox) noexcept;

    display_surface(int __pref_width,
		    int __pref_height,
		    experimental::io2d::format __pref_fmt,
		    int __pref_disp_width,
		    int __pref_disp_height,
		    experimental::io2d::scaling __scl = experimental::io2d::scaling::letterbox);

    display_surface(int __pref_width,
		    int __pref_height,
		    experimental::io2d::format __pref_fmt,
		    int __pref_disp_width,
		    int __pref_disp_height,
		    std::error_code& __ec,
		    experimental::io2d::scaling __scl = experimental::io2d::scaling::letterbox) noexcept;

    virtual ~display_surface();

    // modifiers:

    virtual void
    save() override;

    virtual void
    save(std::error_code& __ec) noexcept override;

    virtual void
    restore() override;

    virtual void
    restore(std::error_code& __ec) noexcept override;

    void
    draw_callback(const std::function<void(display_surface&)>& __fn) noexcept;

    void
    size_change_callback(const std::function<void(display_surface&)>& __fn) noexcept;

    void
    width(int __w);

    void
    width(int __w, std::error_code& __ec) noexcept;

    void
    height(int __h);

    void
    height(int __h, std::error_code& __ec) noexcept;

    void
    display_width(int __w);

    void
    display_width(int __w, std::error_code& __ec) noexcept;

    void
    display_height(int __h);

    void
    display_height(int __h, std::error_code& __ec) noexcept;

    void
    dimensions(int __w, int __h);

    void
    dimensions(int __w, int __h, std::error_code& __ec) noexcept;

    void
    display_dimensions(int __dw, int __dh);

    void
    display_dimensions(int __dw, int __dh, std::error_code& __ec) noexcept;

    void
    scaling(experimental::io2d::scaling __scl) noexcept;

    void
    user_scaling_callback(
	const std::function<experimental::io2d::rectangle(const display_surface&, bool&)>& __fn) noexcept;

    void
    letterbox_brush(experimental::nullopt_t) noexcept;

    void
    letterbox_brush(const rgba_color& __c);

    void
    letterbox_brush(const rgba_color& __c, std::error_code& __ec) noexcept;

    void
    letterbox_brush(const experimental::io2d::brush& __b);

    void
    letterbox_brush(const experimental::io2d::brush& __b, std::error_code& __ec) noexcept;

    void
    auto_clear(bool __val) noexcept;

    int
    show();

    int
    show(std::error_code& __ec);

    void
    exit_show(int __milliseconds);

    void
    exit_show(int __milliseconds, std::error_code& __ec);

    // observers:

    experimental::io2d::format
    format() const noexcept;

    int
    width() const noexcept;

    int
    height() const noexcept;

    int
    display_width() const noexcept;

    int
    display_height() const noexcept;

    std::tuple<int, int>
    dimensions() const noexcept;

    std::tuple<int, int>
    display_dimensions() const noexcept;

    experimental::io2d::scaling
    scaling() const noexcept;

    std::function<experimental::io2d::rectangle(const display_surface&, bool&)>
    user_scaling_callback() const;

    std::function<experimental::io2d::rectangle(const display_surface&, bool&)>
    user_scaling_callback(std::error_code& __ec) const noexcept;

    experimental::io2d::brush
    letterbox_brush() const noexcept;

    bool
    auto_clear() const noexcept;
  };

  /**
   *
   */
  class mapped_surface
  {
  public:

    // construct/copy/move/destroy:

    mapped_surface() = delete;

    mapped_surface(const mapped_surface&) = delete;

    mapped_surface& operator=(const mapped_surface&) = delete;

    mapped_surface(mapped_surface&& __other) = delete;

    mapped_surface& operator=(mapped_surface&& __other) = delete;

    ~mapped_surface();

    // modifiers:

    void
    commit_changes();

    void
    commit_changes(std::error_code& __ec) noexcept;

    void
    commit_changes(const rectangle& __area);

    void
    commit_changes(const rectangle& __area, std::error_code& __ec) noexcept;

    unsigned char*
    data();

    unsigned char*
    data(std::error_code& __ec) noexcept;

    // observers:

    const unsigned char*
    data() const;

    const unsigned char*
    data(std::error_code& __ec) const noexcept;

    experimental::io2d::format
    format() const noexcept;

    int
    width() const noexcept;

    int
    height() const noexcept;

    int
    stride() const noexcept;
  };

  /**
   *
   */
  int
  format_stride_for_width(format __format, int __width) noexcept;

  display_surface
  make_display_surface(int __pref_width,
		       int __pref_height,
		       format __pref_fmt,
		       scaling scl = scaling::letterbox)
  {
    std::error_code __ec;
    auto __dsrf = make_display_surface(__pref_width, __pref_height, __pref_fmt,
				       __ec, __scl);
    if (__ec)
      throw std::someexcept("");
    return __dsrf;
  }

  display_surface
  make_display_surface(int __pref_width,
		       int __pref_height,
		       format __pref_fmt,
		       std::error_code& __ec,
		       scaling scl = scaling::letterbox) noexcept;

  display_surface
  make_display_surface(int __pref_width,
		       int __pref_height,
		       format __pref_fmt,
		       int __pref_disp_width,
		       int __pref_disp_height,
		       scaling scl = scaling::letterbox)
  {
    std::error_code __ec;
    auto __dsrf = make_display_surface(__pref_width, __pref_height, __pref_fmt,
		       __pref_disp_width, __pref_disp_height, __ec, __scl);
    if (__ec)
      throw std::someexcept("");
    return __dsrf;
  }

  display_surface
  make_display_surface(int __pref_width,
		       int __pref_height,
		       format __pref_fmt,
		       int __pref_disp_width,
		       int __pref_disp_height,
		       std::error_code& __ec,
		       scaling __scl = scaling::letterbox) noexcept;

  image_surface
  make_image_surface(format __format,
		     int __width,
		     int __height);

  image_surface
  make_image_surface(format __format,
		     int __width,
		     int __height,
		     std::error_code& __ec) noexcept;

} // inline namespace v1
} // namespace io2d
} // namespace experimental
} // namespace std
